<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.18.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Making an ostream Class &mdash; utilities 1.0.0 documentation</title>
      <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
        <script src="_static/jquery.js"></script>
        <script src="_static/underscore.js"></script>
        <script src="_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script src="_static/doctools.js"></script>
    <script src="_static/js/theme.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="index.html" class="icon icon-home"> utilities
          </a>
              <div class="version">
                1.0.0
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="about/about.html">About</a></li>
<li class="toctree-l1"><a class="reference internal" href="installation/building.html">Building the library</a></li>
<li class="toctree-l1"><a class="reference internal" href="installation/building.html#building-the-documentation">Building the documentation</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">utilities</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="index.html" class="icon icon-home"></a> &raquo;</li>
      <li>Making an ostream Class</li>
      <li class="wy-breadcrumbs-aside">
            <a href="_sources/making_an_ostream.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="making-an-ostream-class">
<h1>Making an ostream Class<a class="headerlink" href="#making-an-ostream-class" title="Permalink to this heading"></a></h1>
<p>It is common C++ practice to make an object of type <code class="docutils literal notranslate"><span class="pre">T</span></code> printable by
overloading the <code class="docutils literal notranslate"><span class="pre">std::ostream&amp;</span> <span class="pre">operator&lt;&lt;(std::ostream&amp;,</span> <span class="pre">T)</span></code> function. Thus if
you want to do special printing a common strategy is to implement a class that
derives from <code class="docutils literal notranslate"><span class="pre">std::ostream</span></code>. Being blunt it’s quite hard to find good
documentation relating to how to do this.</p>
<section id="overview">
<h2>Overview<a class="headerlink" href="#overview" title="Permalink to this heading"></a></h2>
<p>So in the opening we said we want to inherit from <code class="docutils literal notranslate"><span class="pre">std::ostream</span></code>. This is
actually the easy part because that always looks like:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">MyStream</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="k">public</span><span class="w"> </span><span class="n">MyBuffer</span><span class="p">,</span><span class="w"> </span><span class="k">public</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">ostream</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="k">public</span><span class="o">:</span><span class="w"></span>
<span class="w">    </span><span class="n">MyStream</span><span class="p">()</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">MyBuffer</span><span class="p">(),</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">ostream</span><span class="p">(</span><span class="k">this</span><span class="p">)</span><span class="w"> </span><span class="p">{}</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>
</pre></div>
</div>
<p>More specifically <code class="docutils literal notranslate"><span class="pre">std::ostream</span></code> has no virtual functions so you can’t change
it’s behavior that way. Rather what you do is define a new buffer object. Buffer
objects are more or less PIMPLs for the stream. The  <code class="docutils literal notranslate"><span class="pre">std::ostream</span></code> ctor takes
a pointer to the buffer it is supposed to use. Arguably the cleanest way to
store the state of the buffer in the class and ensure the <code class="docutils literal notranslate"><span class="pre">std::ostream</span></code> has
a valid pointer to it is to use multiple inheritance. This is because base
classes are initialized before members of derived classes. Hence, if we put the
buffer in the <code class="docutils literal notranslate"><span class="pre">MyStream</span></code> class it wouldn’t be ready when we need to initialize
the <code class="docutils literal notranslate"><span class="pre">std::ostream</span></code> class. By using multiple inheritance we get to initialize
the base classes in the order they are declared, so we first inherit from our
buffer (which is currently hidden behind behind the opaque type <code class="docutils literal notranslate"><span class="pre">MyBuffer</span></code>)
and then provide the <code class="docutils literal notranslate"><span class="pre">this</span></code> pointer to <code class="docutils literal notranslate"><span class="pre">std::ostream</span></code>.</p>
<p>To get our stream to do what we want, we have to write our own buffer class
that derives from <code class="docutils literal notranslate"><span class="pre">std::basic_streambuf&lt;T&gt;</span></code> where <code class="docutils literal notranslate"><span class="pre">T</span></code> is the type used to
hold the characters of the stream. Typically you want this to either be <code class="docutils literal notranslate"><span class="pre">char</span></code>
or <code class="docutils literal notranslate"><span class="pre">wchar_t</span></code> and the STL provides typedefs for you (<code class="docutils literal notranslate"><span class="pre">std::streambuf</span></code> and
<code class="docutils literal notranslate"><span class="pre">std::wstreambuf</span></code> respectively). Our plan is thus to define a class
<code class="docutils literal notranslate"><span class="pre">MyBuffer</span></code> that derives from``std::basic_streambuf&lt;T&gt;`` and properly overrides
the virtual functions. One should note that <code class="docutils literal notranslate"><span class="pre">std::ostream</span></code> is actually a
similar typedef of <code class="docutils literal notranslate"><span class="pre">std::basic_ostream&lt;char&gt;</span></code> hence it’s necessary to ensure
that the buffer class we write has the same template type parameter.</p>
<p>This is where things get tricky, as the documentation for
the virtual functions is a bit archaic.</p>
</section>
<section id="std-basic-streambuf">
<h2>std::basic_streambuf<a class="headerlink" href="#std-basic-streambuf" title="Permalink to this heading"></a></h2>
<p>This is the class that actually does all the work for a stream. Internally it
can have buffers for input and/or output. These buffers are described by six
pointers, which are referred to by the names of the member functions for
retrieving the pointer:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">eback</span></code> a pointer to the beginning of the input buffer</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">gptr()</span></code> the current position in the input buffer</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">egptr()</span></code> pointer to just past the end of the input buffer</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pbase()</span></code> beginning of the output buffer</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pptr()</span></code> current position in the output buffer</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">epptr()</span></code> pointer to just past the end of the output buffer</p></li>
</ul>
<p>If you’re trying to make sense of the names <code class="docutils literal notranslate"><span class="pre">gptr()</span></code> stands for the
“get pointer” and <code class="docutils literal notranslate"><span class="pre">pptr()</span></code> stands for the “put pointer”. Those two seem to be
rigorously defined. I can’t find definitions for the others, but my guesses
(which help me mnemonically at least) are that the “e” in the “e” prefixed
versions (<code class="docutils literal notranslate"><span class="pre">egptr()</span></code> and <code class="docutils literal notranslate"><span class="pre">epptr()</span></code>) stands for “end”, <code class="docutils literal notranslate"><span class="pre">pbase</span></code> stands for
the “base” of the put array, and I’m really not sure about <code class="docutils literal notranslate"><span class="pre">eback</span></code>, but by
process of elimination it must be the start of the input buffer…</p>
<p>By default all of these pointers are null, which means that every write/read
will overflow/underflow. Your class needs to maintain these pointers if it
actually has an internal buffer. To set the output pointers use the <code class="docutils literal notranslate"><span class="pre">setp</span></code>
function and to set the input pointers use <code class="docutils literal notranslate"><span class="pre">setg</span></code>. The input to these
functions are the new beginning and end pointers; the current position will
automatically be set to the beginning.</p>
<p>Anyways, internally <code class="docutils literal notranslate"><span class="pre">operator&lt;&lt;</span></code> attempts to put data into the output buffer.
If it can not put anymore data into that buffer, an overflow occurs. The actual
writes to the buffer go through <code class="docutils literal notranslate"><span class="pre">sputc</span></code> or <code class="docutils literal notranslate"><span class="pre">sputn</span></code> depending on the number
of characters to write. <code class="docutils literal notranslate"><span class="pre">sputc</span></code> is called when there is a single character to
write and looks something like:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">int_type</span><span class="w"> </span><span class="nf">sputc</span><span class="p">(</span><span class="n">char_type</span><span class="w"> </span><span class="n">c</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">int_type</span><span class="w"> </span><span class="n">ic</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">traits_type</span><span class="o">::</span><span class="n">to_int_type</span><span class="p">(</span><span class="n">c</span><span class="p">);</span><span class="w"> </span><span class="c1">//Turn c into an integer type</span>
<span class="w">    </span><span class="k">if</span><span class="p">(</span><span class="w"> </span><span class="o">!</span><span class="n">pptr</span><span class="p">()</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="n">pptr</span><span class="p">()</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">epptr</span><span class="p">()</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="c1">//overflow</span>
<span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="n">overflow</span><span class="p">(</span><span class="n">ic</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="o">*</span><span class="n">pptr</span><span class="p">()</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">c</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">pbump</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span><span class="w"> </span><span class="c1">//advances the put pointer by 1</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">ic</span><span class="o">:</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>Basically <code class="docutils literal notranslate"><span class="pre">sputc</span></code> takes care of writing characters to the buffer, one at a
time, until it can’t. When it can’t it defers to the <code class="docutils literal notranslate"><span class="pre">overflow</span></code> function. By
default the <code class="docutils literal notranslate"><span class="pre">overflow</span></code> function just returns <code class="docutils literal notranslate"><span class="pre">traits_type::eof()</span></code>, which
signals failure to handle the overflow. If you want your buffer class to be an
output buffer, then you need to override <code class="docutils literal notranslate"><span class="pre">overflow</span></code> as shown below.</p>
<p>Writing one character at a time is inefficient, which is why
<code class="docutils literal notranslate"><span class="pre">std::basic_streambuf</span></code> also has <code class="docutils literal notranslate"><span class="pre">sputn</span></code>. <code class="docutils literal notranslate"><span class="pre">sputn</span></code>’s signature is:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">streamsize</span><span class="w"> </span><span class="nf">sputn</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">char_type</span><span class="o">&amp;</span><span class="w"> </span><span class="n">s</span><span class="p">,</span><span class="w"> </span><span class="n">streamsize</span><span class="w"> </span><span class="n">n</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>When called, <code class="docutils literal notranslate"><span class="pre">sputn</span></code> attempts to write at most <code class="docutils literal notranslate"><span class="pre">n</span></code> characters from the
stream which starts at <code class="docutils literal notranslate"><span class="pre">s</span></code>. It returns the number of characters actually
written (if an overflow occurs then only some of the <code class="docutils literal notranslate"><span class="pre">n</span></code> characters are
written). <code class="docutils literal notranslate"><span class="pre">sputn</span></code> basically just calls <code class="docutils literal notranslate"><span class="pre">xsputn</span></code>, which is a virtual member
function that can be overriden by your class. By default, <code class="docutils literal notranslate"><span class="pre">xsputn</span></code> just calls
<code class="docutils literal notranslate"><span class="pre">sputc</span></code>, <code class="docutils literal notranslate"><span class="pre">n</span></code> times, stopping if any of the calls to <code class="docutils literal notranslate"><span class="pre">sputc</span></code> return
<code class="docutils literal notranslate"><span class="pre">traits_type::eof()</span></code>.</p>
<p>For writing data to a buffer <code class="docutils literal notranslate"><span class="pre">overflow</span></code> and <code class="docutils literal notranslate"><span class="pre">xsputn</span></code> are the major virtual
functions you need to implement. Depending on how your buffer works you also
want to be aware of:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">sync</span></code> called when the user wants to force a flush. By default this function
does nothing. So if your buffer does not automatically write its data to its
final destination you need to override this function.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">seekoff</span></code> called to move either <code class="docutils literal notranslate"><span class="pre">gptr()</span></code> or <code class="docutils literal notranslate"><span class="pre">pptr()</span></code> to a new location,
with the location specified relative to the beginning, current position, or
end of the respective internal buffer. Default behavior is to do nothing and
return -1.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">seekpos</span></code> similar to <code class="docutils literal notranslate"><span class="pre">seekpos</span></code> except it moves the pointer to the
specified absolute position.</p></li>
</ul>
<p>The following sections provide more details on the virtual functions that are
relevant for writing a custom output buffer.</p>
</section>
<section id="xsputn">
<h2>xsputn<a class="headerlink" href="#xsputn" title="Permalink to this heading"></a></h2>
<p>This function will ultimately be called everytime the stream wants to write more
than one character. It’s signature is:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">std</span><span class="o">::</span><span class="n">streamsize</span><span class="w"> </span><span class="n">xsputn</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="o">*</span><span class="w"> </span><span class="n">s</span><span class="p">,</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">streamsize</span><span class="w"> </span><span class="n">n</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
<p>It takes a pointer to an array of characters and the length of that array. Your
buffer class’s implementation of this function should write as many of the
provided characters as possible to the output buffer. After writing either the
entire array, or as many characters as it can, your implementation should return
the nuumber of characters it actually wrote.</p>
<p>The base class provides a default implementation, which just calls <code class="docutils literal notranslate"><span class="pre">sputc</span></code>
until <code class="docutils literal notranslate"><span class="pre">sputc</span></code> returns <code class="docutils literal notranslate"><span class="pre">traits_type::eof()</span></code> (hence signaling an error) or all
characters have been written.</p>
</section>
<section id="overflow">
<h2>overflow<a class="headerlink" href="#overflow" title="Permalink to this heading"></a></h2>
<p><code class="docutils literal notranslate"><span class="pre">overflow</span></code> is called when the <code class="docutils literal notranslate"><span class="pre">pptr()</span></code> is no longer valid. Its signature is:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">int_type</span><span class="w"> </span><span class="nf">overflow</span><span class="p">(</span><span class="n">int_type</span><span class="w"> </span><span class="n">c</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>The input value, <code class="docutils literal notranslate"><span class="pre">c</span></code>, is the character which could not fit in the internal
output buffer. Your implementation is allowed to make more room in the internal
output buffer (if you do this you need to adjust, <code class="docutils literal notranslate"><span class="pre">pbase()</span></code>, <code class="docutils literal notranslate"><span class="pre">pptr()</span></code>, and
<code class="docutils literal notranslate"><span class="pre">epptr()</span></code>). If you do not make room then you need to write  <code class="docutils literal notranslate"><span class="pre">c</span></code> to the
output. The return is <code class="docutils literal notranslate"><span class="pre">c</span></code>, if <code class="docutils literal notranslate"><span class="pre">overflow</span></code> was successful or
<code class="docutils literal notranslate"><span class="pre">traits_type::eof()</span></code> if an error occurred.</p>
</section>
<section id="synch">
<h2>synch<a class="headerlink" href="#synch" title="Permalink to this heading"></a></h2>
<p>If a user calls flush on the <code class="docutils literal notranslate"><span class="pre">std::ostream</span></code> object it ultimately will call
<code class="docutils literal notranslate"><span class="pre">synch</span></code>. <code class="docutils literal notranslate"><span class="pre">synch</span></code>’s signature is:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span><span class="w"> </span><span class="n">synch</span><span class="p">()</span><span class="w"></span>
</pre></div>
</div>
<p>It returns 0 if successful and -1 if it fails. Your implementation should dump
whatever’s in the internal output buffer to the output and reset the pointers.</p>
</section>
<section id="seekoff">
<h2>seekoff<a class="headerlink" href="#seekoff" title="Permalink to this heading"></a></h2>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">pos_type</span><span class="w"> </span><span class="n">seekoff</span><span class="p">(</span><span class="n">off_type</span><span class="w"> </span><span class="n">off</span><span class="p">,</span><span class="w"></span>
<span class="w">                 </span><span class="n">ios_base</span><span class="o">::</span><span class="n">seekdir</span><span class="w"> </span><span class="n">way</span><span class="p">,</span><span class="w"></span>
<span class="w">                 </span><span class="n">ios_base</span><span class="o">::</span><span class="n">openmode</span><span class="w"> </span><span class="n">which</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
</section>
<section id="seekpos">
<h2>seekpos<a class="headerlink" href="#seekpos" title="Permalink to this heading"></a></h2>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">pos_type</span><span class="w"> </span><span class="n">seekpos</span><span class="p">(</span><span class="n">pos_type</span><span class="w"> </span><span class="n">pos</span><span class="p">,</span><span class="w"> </span><span class="n">ios_base</span><span class="o">::</span><span class="n">openmode</span><span class="w"> </span><span class="n">which</span><span class="p">)</span><span class="w"></span>
</pre></div>
</div>
</section>
</section>


           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2020, NWChemEx Team.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>