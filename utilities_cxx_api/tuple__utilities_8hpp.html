<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>utilities: utilities/type_traits/tuple/tuple_utilities.hpp File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">utilities
   &#160;<span id="projectnumber">1.0.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_df38b2a5d584e0f6066b4518b95c638b.html">utilities</a></li><li class="navelem"><a class="el" href="dir_ed90f5410931edfc66bdac238edfef04.html">type_traits</a></li><li class="navelem"><a class="el" href="dir_80f0fec9914ea4b1b71dd1ece39819f2.html">tuple</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">tuple_utilities.hpp File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &quot;utilities/type_traits/type_traits_extensions.hpp&quot;</code><br />
<code>#include &lt;tuple&gt;</code><br />
<code>#include &lt;type_traits&gt;</code><br />
</div>
<p><a href="tuple__utilities_8hpp_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespaceutilities"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceutilities.html">utilities</a></td></tr>
<tr class="memdesc:namespaceutilities"><td class="mdescLeft">&#160;</td><td class="mdescRight">Main namespace for the Utilities library. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceutilities_1_1detail__"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceutilities_1_1detail__.html">utilities::detail_</a></td></tr>
<tr class="memdesc:namespaceutilities_1_1detail__"><td class="mdescLeft">&#160;</td><td class="mdescRight">Name space for things not mean to see the light of day. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:aeddd9d8d94a6cf1bf6d30157da8b71c8"><td class="memTemplParams" colspan="2">template&lt;std::size_t I, typename tuple_type &gt; </td></tr>
<tr class="memitem:aeddd9d8d94a6cf1bf6d30157da8b71c8"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceutilities_1_1detail__.html#aeddd9d8d94a6cf1bf6d30157da8b71c8">utilities::detail_::recursion_done</a> = std::is_same&lt; std::integral_constant&lt; std::size_t, I &gt;, std::integral_constant&lt; std::size_t, std::tuple_size&lt; std::decay_t&lt; tuple_type &gt; &gt;::value &gt; &gt;</td></tr>
<tr class="memdesc:aeddd9d8d94a6cf1bf6d30157da8b71c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type that will tell us if we have iterated over all elements of a tuple.  <a href="namespaceutilities_1_1detail__.html#aeddd9d8d94a6cf1bf6d30157da8b71c8">More...</a><br /></td></tr>
<tr class="separator:aeddd9d8d94a6cf1bf6d30157da8b71c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae23ecb9c53e5e2876bf8853de2b39298"><td class="memTemplParams" colspan="2">template&lt;std::size_t I, typename tuple_type &gt; </td></tr>
<tr class="memitem:ae23ecb9c53e5e2876bf8853de2b39298"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceutilities_1_1detail__.html#ae23ecb9c53e5e2876bf8853de2b39298">utilities::detail_::recursion_not_done</a> = Negation&lt; recursion_done&lt; I, tuple_type &gt; &gt;</td></tr>
<tr class="memdesc:ae23ecb9c53e5e2876bf8853de2b39298"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type that will tell us if we are not done iterating over all elements of a tuple.  <a href="namespaceutilities_1_1detail__.html#ae23ecb9c53e5e2876bf8853de2b39298">More...</a><br /></td></tr>
<tr class="separator:ae23ecb9c53e5e2876bf8853de2b39298"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4199309c10a7c0c88f83d16fc58a9f48"><td class="memTemplParams" colspan="2"><a id="a4199309c10a7c0c88f83d16fc58a9f48"></a>
template&lt;std::size_t I, typename tuple_type &gt; </td></tr>
<tr class="memitem:a4199309c10a7c0c88f83d16fc58a9f48"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceutilities_1_1detail__.html#a4199309c10a7c0c88f83d16fc58a9f48">utilities::detail_::done_recursing</a> = std::enable_if&lt; recursion_done&lt; I, tuple_type &gt;::value, int &gt;</td></tr>
<tr class="memdesc:a4199309c10a7c0c88f83d16fc58a9f48"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enables a function via SFINAE if recursion through a tuple has finished. <br /></td></tr>
<tr class="separator:a4199309c10a7c0c88f83d16fc58a9f48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a352e0e0d09d4d05cb740d5d5b6b3175d"><td class="memTemplParams" colspan="2"><a id="a352e0e0d09d4d05cb740d5d5b6b3175d"></a>
template&lt;std::size_t I, typename tuple_type &gt; </td></tr>
<tr class="memitem:a352e0e0d09d4d05cb740d5d5b6b3175d"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceutilities_1_1detail__.html#a352e0e0d09d4d05cb740d5d5b6b3175d">utilities::detail_::recursing</a> = std::enable_if&lt; recursion_not_done&lt; I, tuple_type &gt;::value, int &gt;</td></tr>
<tr class="memdesc:a352e0e0d09d4d05cb740d5d5b6b3175d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enables a function via SFINAE if recursion through a tuple is still going. <br /></td></tr>
<tr class="separator:a352e0e0d09d4d05cb740d5d5b6b3175d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a65f6b0b27eb811af5dfe47680247ea92"><td class="memTemplParams" colspan="2"><a id="a65f6b0b27eb811af5dfe47680247ea92"></a>
template&lt;typename tuple_type , typename functor_type , std::size_t... I&gt; </td></tr>
<tr class="memitem:a65f6b0b27eb811af5dfe47680247ea92"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceutilities_1_1detail__.html#a65f6b0b27eb811af5dfe47680247ea92">utilities::detail_::tuple_transform_impl</a> (tuple_type &amp;&amp;tuple, functor_type &amp;&amp;functor, std::index_sequence&lt; I... &gt;)</td></tr>
<tr class="memdesc:a65f6b0b27eb811af5dfe47680247ea92"><td class="mdescLeft">&#160;</td><td class="mdescRight">Actually implements the tuple_transform function. <br /></td></tr>
<tr class="separator:a65f6b0b27eb811af5dfe47680247ea92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5545286e54a5a7e81fd3d97d18aca72"><td class="memTemplParams" colspan="2"><a id="ae5545286e54a5a7e81fd3d97d18aca72"></a>
template&lt;typename lhs_type , typename rhs_type , typename functor_type , std::size_t... I&gt; </td></tr>
<tr class="memitem:ae5545286e54a5a7e81fd3d97d18aca72"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceutilities_1_1detail__.html#ae5545286e54a5a7e81fd3d97d18aca72">utilities::detail_::tuple_transform_impl</a> (lhs_type &amp;&amp;lhs, rhs_type &amp;&amp;rhs, functor_type &amp;&amp;functor, std::index_sequence&lt; I... &gt;)</td></tr>
<tr class="memdesc:ae5545286e54a5a7e81fd3d97d18aca72"><td class="mdescLeft">&#160;</td><td class="mdescRight">The guts behind actually combining tuples via a functor. <br /></td></tr>
<tr class="separator:ae5545286e54a5a7e81fd3d97d18aca72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3758b4759605d7c6ca9bb4d5e69fdb57"><td class="memTemplParams" colspan="2">template&lt;std::size_t I, typename tuple_type , typename functor_type , typename return_type , typename done_recursing&lt; I, tuple_type &gt;::type  = 0&gt; </td></tr>
<tr class="memitem:a3758b4759605d7c6ca9bb4d5e69fdb57"><td class="memTemplItemLeft" align="right" valign="top">return_type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceutilities_1_1detail__.html#a3758b4759605d7c6ca9bb4d5e69fdb57">utilities::detail_::tuple_accumulate_impl</a> (tuple_type &amp;&amp;, functor_type &amp;&amp;, return_type val)</td></tr>
<tr class="memdesc:a3758b4759605d7c6ca9bb4d5e69fdb57"><td class="mdescLeft">&#160;</td><td class="mdescRight">End-point for reducing a tuple.  <a href="namespaceutilities_1_1detail__.html#a3758b4759605d7c6ca9bb4d5e69fdb57">More...</a><br /></td></tr>
<tr class="separator:a3758b4759605d7c6ca9bb4d5e69fdb57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab27f6987dda064628345bbd90a6832f9"><td class="memTemplParams" colspan="2"><a id="ab27f6987dda064628345bbd90a6832f9"></a>
template&lt;std::size_t I, typename tuple_type , typename functor_type , typename done_recursing&lt; I, tuple_type &gt;::type  = 0&gt; </td></tr>
<tr class="memitem:ab27f6987dda064628345bbd90a6832f9"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><b>utilities::detail_::tuple_find_if_impl</b> (tuple_type &amp;&amp;t, functor_type &amp;&amp;functor)</td></tr>
<tr class="separator:ab27f6987dda064628345bbd90a6832f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad027649c245bd7e411e2155305cef0b2"><td class="memTemplParams" colspan="2">template&lt;typename tuple_type , typename functor_type &gt; </td></tr>
<tr class="memitem:ad027649c245bd7e411e2155305cef0b2"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceutilities.html#ad027649c245bd7e411e2155305cef0b2">utilities::tuple_transform</a> (tuple_type &amp;&amp;tuple, functor_type &amp;&amp;functor)</td></tr>
<tr class="memdesc:ad027649c245bd7e411e2155305cef0b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a tuple of objects this function will apply a functor to each of them and return the results as a tuple.  <a href="namespaceutilities.html#ad027649c245bd7e411e2155305cef0b2">More...</a><br /></td></tr>
<tr class="separator:ad027649c245bd7e411e2155305cef0b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace8cac62cfa90cdf3463f1112b5b6bcc"><td class="memTemplParams" colspan="2">template&lt;typename lhs_type , typename rhs_type , typename functor_type &gt; </td></tr>
<tr class="memitem:ace8cac62cfa90cdf3463f1112b5b6bcc"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceutilities.html#ace8cac62cfa90cdf3463f1112b5b6bcc">utilities::tuple_transform</a> (lhs_type &amp;&amp;lhs, rhs_type &amp;&amp;rhs, functor_type &amp;&amp;functor)</td></tr>
<tr class="memdesc:ace8cac62cfa90cdf3463f1112b5b6bcc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies a binary operation two tuples returning the result.  <a href="namespaceutilities.html#ace8cac62cfa90cdf3463f1112b5b6bcc">More...</a><br /></td></tr>
<tr class="separator:ace8cac62cfa90cdf3463f1112b5b6bcc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae651021596ff36720a7654eb78fce2b5"><td class="memTemplParams" colspan="2">template&lt;typename tuple_type , typename functor_type , typename return_type &gt; </td></tr>
<tr class="memitem:ae651021596ff36720a7654eb78fce2b5"><td class="memTemplItemLeft" align="right" valign="top">return_type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceutilities.html#ae651021596ff36720a7654eb78fce2b5">utilities::tuple_accumulate</a> (tuple_type &amp;&amp;tuple, functor_type &amp;&amp;functor, return_type val)</td></tr>
<tr class="memdesc:ae651021596ff36720a7654eb78fce2b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies a reduction to a tuple.  <a href="namespaceutilities.html#ae651021596ff36720a7654eb78fce2b5">More...</a><br /></td></tr>
<tr class="separator:ae651021596ff36720a7654eb78fce2b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2be3eccba3a5a2e170aec27390a6d1d5"><td class="memTemplParams" colspan="2">template&lt;typename tuple_type , typename functor_type &gt; </td></tr>
<tr class="memitem:a2be3eccba3a5a2e170aec27390a6d1d5"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceutilities.html#a2be3eccba3a5a2e170aec27390a6d1d5">utilities::tuple_find_if</a> (tuple_type &amp;&amp;t, functor_type &amp;&amp;functor)</td></tr>
<tr class="memdesc:a2be3eccba3a5a2e170aec27390a6d1d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies a functor to each element of a tuple and returns the index of the tuple element for which the functor first evaluates to true.  <a href="namespaceutilities.html#a2be3eccba3a5a2e170aec27390a6d1d5">More...</a><br /></td></tr>
<tr class="separator:a2be3eccba3a5a2e170aec27390a6d1d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>This file collects a series of useful utilities for doing template meta-programming using tuples. Their actual definitions are a bit messy so it is highly recommended you consult their documentation or the tests to see how to use them. For the most part the algorithms in this file strive to emulate the STL container routines with similar names.</p>
<ul>
<li>tuple_transform: element-wise applies a unary/binary functor to a tuple/pair of tuples and collects the results in a new tuple</li>
<li>tuple_accumulate: applies a functor to each element of a tuple and accumulates the results in a single value</li>
<li>tuple_find_if: returns the first index of the tuple element for which a functor returns true </li>
</ul>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
