<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>utilities: utilities::IndexableContainerBase&lt; DerivedType &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">utilities
   &#160;<span id="projectnumber">1.0.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceutilities.html">utilities</a></li><li class="navelem"><a class="el" href="classutilities_1_1IndexableContainerBase.html">IndexableContainerBase</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#related">Related Functions</a> &#124;
<a href="classutilities_1_1IndexableContainerBase-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">utilities::IndexableContainerBase&lt; DerivedType &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Code factorization for a container that supports indexing.  
 <a href="classutilities_1_1IndexableContainerBase.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="indexable__container__base_8hpp_source.html">indexable_container_base.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:abffb9e1bccc5e96f6a255e3879cf5cbd"><td class="memItemLeft" align="right" valign="top"><a id="abffb9e1bccc5e96f6a255e3879cf5cbd"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classutilities_1_1IndexableContainerBase.html#abffb9e1bccc5e96f6a255e3879cf5cbd">size_type</a> = std::size_t</td></tr>
<tr class="memdesc:abffb9e1bccc5e96f6a255e3879cf5cbd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type used for indexing and offsets, unsigned integral POD type. <br /></td></tr>
<tr class="separator:abffb9e1bccc5e96f6a255e3879cf5cbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0e9d4191449adbdf96fa8da58675e4e"><td class="memItemLeft" align="right" valign="top"><a id="ab0e9d4191449adbdf96fa8da58675e4e"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classutilities_1_1IndexableContainerBase.html#ab0e9d4191449adbdf96fa8da58675e4e">iterator</a> = <a class="el" href="classutilities_1_1iterators_1_1OffsetIterator.html">iterators::OffsetIterator</a>&lt; DerivedType &gt;</td></tr>
<tr class="memdesc:ab0e9d4191449adbdf96fa8da58675e4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of a random-access iterator that can modify the container. <br /></td></tr>
<tr class="separator:ab0e9d4191449adbdf96fa8da58675e4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a63123c05b94040e275b4487cb9fa28"><td class="memItemLeft" align="right" valign="top"><a id="a4a63123c05b94040e275b4487cb9fa28"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classutilities_1_1IndexableContainerBase.html#a4a63123c05b94040e275b4487cb9fa28">const_iterator</a> = <a class="el" href="classutilities_1_1iterators_1_1OffsetIterator.html">iterators::OffsetIterator</a>&lt; const DerivedType &gt;</td></tr>
<tr class="memdesc:a4a63123c05b94040e275b4487cb9fa28"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of a random-access iterator to a read-only container instance. <br /></td></tr>
<tr class="separator:a4a63123c05b94040e275b4487cb9fa28"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:acb0a8881ca1bd39fb410847cad9ffcf3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classutilities_1_1IndexableContainerBase.html#acb0a8881ca1bd39fb410847cad9ffcf3">empty</a> () const noexcept</td></tr>
<tr class="memdesc:acb0a8881ca1bd39fb410847cad9ffcf3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if the container has any elements in it or not.  <a href="classutilities_1_1IndexableContainerBase.html#acb0a8881ca1bd39fb410847cad9ffcf3">More...</a><br /></td></tr>
<tr class="separator:acb0a8881ca1bd39fb410847cad9ffcf3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44d61c5622fad0691278da6aed0ffad4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classutilities_1_1IndexableContainerBase.html#abffb9e1bccc5e96f6a255e3879cf5cbd">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classutilities_1_1IndexableContainerBase.html#a44d61c5622fad0691278da6aed0ffad4">size</a> () const noexcept</td></tr>
<tr class="memdesc:a44d61c5622fad0691278da6aed0ffad4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines the number of elements in the container.  <a href="classutilities_1_1IndexableContainerBase.html#a44d61c5622fad0691278da6aed0ffad4">More...</a><br /></td></tr>
<tr class="separator:a44d61c5622fad0691278da6aed0ffad4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1d63487f1dcdb974df4ea778f80e0c5"><td class="memItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classutilities_1_1IndexableContainerBase.html#af1d63487f1dcdb974df4ea778f80e0c5">operator[]</a> (<a class="el" href="classutilities_1_1IndexableContainerBase.html#abffb9e1bccc5e96f6a255e3879cf5cbd">size_type</a> index)</td></tr>
<tr class="memdesc:af1d63487f1dcdb974df4ea778f80e0c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves an element from the container by index.  <a href="classutilities_1_1IndexableContainerBase.html#af1d63487f1dcdb974df4ea778f80e0c5">More...</a><br /></td></tr>
<tr class="separator:af1d63487f1dcdb974df4ea778f80e0c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03cb6845ef691898e764821d631dc941"><td class="memItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classutilities_1_1IndexableContainerBase.html#a03cb6845ef691898e764821d631dc941">operator[]</a> (<a class="el" href="classutilities_1_1IndexableContainerBase.html#abffb9e1bccc5e96f6a255e3879cf5cbd">size_type</a> index) const</td></tr>
<tr class="memdesc:a03cb6845ef691898e764821d631dc941"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves an element from the container by index.  <a href="classutilities_1_1IndexableContainerBase.html#a03cb6845ef691898e764821d631dc941">More...</a><br /></td></tr>
<tr class="separator:a03cb6845ef691898e764821d631dc941"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42154c41ac8331aaaef69b616e093ee5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classutilities_1_1IndexableContainerBase.html#ab0e9d4191449adbdf96fa8da58675e4e">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classutilities_1_1IndexableContainerBase.html#a42154c41ac8331aaaef69b616e093ee5">begin</a> () noexcept</td></tr>
<tr class="memdesc:a42154c41ac8331aaaef69b616e093ee5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator pointing at the first element in the container.  <a href="classutilities_1_1IndexableContainerBase.html#a42154c41ac8331aaaef69b616e093ee5">More...</a><br /></td></tr>
<tr class="separator:a42154c41ac8331aaaef69b616e093ee5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfef31a5bbbfa0d1b6ee3034d83ecdfb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classutilities_1_1IndexableContainerBase.html#a4a63123c05b94040e275b4487cb9fa28">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classutilities_1_1IndexableContainerBase.html#abfef31a5bbbfa0d1b6ee3034d83ecdfb">begin</a> () const noexcept</td></tr>
<tr class="memdesc:abfef31a5bbbfa0d1b6ee3034d83ecdfb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator pointing at the first element in the container.  <a href="classutilities_1_1IndexableContainerBase.html#abfef31a5bbbfa0d1b6ee3034d83ecdfb">More...</a><br /></td></tr>
<tr class="separator:abfef31a5bbbfa0d1b6ee3034d83ecdfb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9197cb8551971223b58afc8a99bd45b1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classutilities_1_1IndexableContainerBase.html#a4a63123c05b94040e275b4487cb9fa28">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classutilities_1_1IndexableContainerBase.html#a9197cb8551971223b58afc8a99bd45b1">cbegin</a> () const noexcept</td></tr>
<tr class="memdesc:a9197cb8551971223b58afc8a99bd45b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator pointing at the first element in the container.  <a href="classutilities_1_1IndexableContainerBase.html#a9197cb8551971223b58afc8a99bd45b1">More...</a><br /></td></tr>
<tr class="separator:a9197cb8551971223b58afc8a99bd45b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acca04d9cf31e393f9f08f06442056e63"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classutilities_1_1IndexableContainerBase.html#ab0e9d4191449adbdf96fa8da58675e4e">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classutilities_1_1IndexableContainerBase.html#acca04d9cf31e393f9f08f06442056e63">end</a> () noexcept</td></tr>
<tr class="memdesc:acca04d9cf31e393f9f08f06442056e63"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator just past the end of the container.  <a href="classutilities_1_1IndexableContainerBase.html#acca04d9cf31e393f9f08f06442056e63">More...</a><br /></td></tr>
<tr class="separator:acca04d9cf31e393f9f08f06442056e63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b0f654673ca8e974ff6f923d5e54b05"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classutilities_1_1IndexableContainerBase.html#a4a63123c05b94040e275b4487cb9fa28">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classutilities_1_1IndexableContainerBase.html#a1b0f654673ca8e974ff6f923d5e54b05">end</a> () const noexcept</td></tr>
<tr class="memdesc:a1b0f654673ca8e974ff6f923d5e54b05"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator just past the end of the container.  <a href="classutilities_1_1IndexableContainerBase.html#a1b0f654673ca8e974ff6f923d5e54b05">More...</a><br /></td></tr>
<tr class="separator:a1b0f654673ca8e974ff6f923d5e54b05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1ed119bdd7cc678c5e164fb0e792bad"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classutilities_1_1IndexableContainerBase.html#a4a63123c05b94040e275b4487cb9fa28">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classutilities_1_1IndexableContainerBase.html#aa1ed119bdd7cc678c5e164fb0e792bad">cend</a> () const noexcept</td></tr>
<tr class="memdesc:aa1ed119bdd7cc678c5e164fb0e792bad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator just past the end of the container.  <a href="classutilities_1_1IndexableContainerBase.html#aa1ed119bdd7cc678c5e164fb0e792bad">More...</a><br /></td></tr>
<tr class="separator:aa1ed119bdd7cc678c5e164fb0e792bad"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="related"></a>
Related Functions</h2></td></tr>
<tr><td class="ititle" colspan="2"><p>(Note that these are not member functions.) </p>
</td></tr>
<tr class="memitem:a36214ed92d82cef2963cbba092bbbefd"><td class="memTemplParams" colspan="2">template&lt;typename DerivedType &gt; </td></tr>
<tr class="memitem:a36214ed92d82cef2963cbba092bbbefd"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classutilities_1_1IndexableContainerBase.html#a36214ed92d82cef2963cbba092bbbefd">operator==</a> (const <a class="el" href="classutilities_1_1IndexableContainerBase.html">IndexableContainerBase</a>&lt; DerivedType &gt; &amp;lhs, const <a class="el" href="classutilities_1_1IndexableContainerBase.html">IndexableContainerBase</a>&lt; DerivedType &gt; &amp;rhs) noexcept</td></tr>
<tr class="memdesc:a36214ed92d82cef2963cbba092bbbefd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares two <a class="el" href="classutilities_1_1IndexableContainerBase.html" title="Code factorization for a container that supports indexing.">IndexableContainerBase</a> instances for equality.  <a href="classutilities_1_1IndexableContainerBase.html#a36214ed92d82cef2963cbba092bbbefd">More...</a><br /></td></tr>
<tr class="separator:a36214ed92d82cef2963cbba092bbbefd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71944cf326d967694d7394081e67c166"><td class="memTemplParams" colspan="2">template&lt;typename DerivedType &gt; </td></tr>
<tr class="memitem:a71944cf326d967694d7394081e67c166"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classutilities_1_1IndexableContainerBase.html#a71944cf326d967694d7394081e67c166">operator!=</a> (const <a class="el" href="classutilities_1_1IndexableContainerBase.html">IndexableContainerBase</a>&lt; DerivedType &gt; &amp;lhs, const <a class="el" href="classutilities_1_1IndexableContainerBase.html">IndexableContainerBase</a>&lt; DerivedType &gt; &amp;rhs) noexcept</td></tr>
<tr class="memdesc:a71944cf326d967694d7394081e67c166"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if two <a class="el" href="classutilities_1_1IndexableContainerBase.html" title="Code factorization for a container that supports indexing.">IndexableContainerBase</a> instances are different.  <a href="classutilities_1_1IndexableContainerBase.html#a71944cf326d967694d7394081e67c166">More...</a><br /></td></tr>
<tr class="separator:a71944cf326d967694d7394081e67c166"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename DerivedType&gt;<br />
class utilities::IndexableContainerBase&lt; DerivedType &gt;</h3>

<p>Code factorization for a container that supports indexing. </p>
<p>When creating new classes it is not uncommon to need classes that are container-like. This class in particular is useful for when the resulting class should be an indexable container. By this we mean that it should satisfy the C++ concept of "container" and users of the container can retrieve elements by an integral index/offset.</p>
<p>To use this class derive from it and in your derived class implement:</p><ul>
<li><code>size_type size_() const noexcept</code> - Should return the number of elements in your container. The implementing function should not throw.</li>
<li><code>reference at_(size_type)</code> - Should return a (possibly) modifiable reference to the requested element (the provided argument being the index of the requested element). Whether the returned reference is actually modifiable is upt to the implementation (the implementation is free to return a constant reference if the container should be read-only).</li>
<li><code>const_reference at_(size_type) const</code> - same as the non-const version except that it should return the element in a read-only manner.</li>
</ul>
<p>Additionally your class must define a typedef <code>value_type</code> which is the non-cv-qualified type of the elements in the container.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">DerivedType</td><td>The type of the container that is being implemented. The <a class="el" href="classutilities_1_1IndexableContainerBase.html" title="Code factorization for a container that supports indexing.">IndexableContainerBase</a> class works off of the CRTP and will use the DerivedType to implement the container API. </td></tr>
  </table>
  </dd>
</dl>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="abfef31a5bbbfa0d1b6ee3034d83ecdfb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abfef31a5bbbfa0d1b6ee3034d83ecdfb">&#9670;&nbsp;</a></span>begin() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classutilities_1_1IndexableContainerBase.html#a4a63123c05b94040e275b4487cb9fa28">const_iterator</a> <a class="el" href="classutilities_1_1IndexableContainerBase.html">utilities::IndexableContainerBase</a>&lt; DerivedType &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator pointing at the first element in the container. </p>
<p>This member function is used to create an iterator that points to the first element in the container. If the container is empty the resulting iterator will be identical to the iterator returned by <code><a class="el" href="classutilities_1_1IndexableContainerBase.html#acca04d9cf31e393f9f08f06442056e63" title="Returns an iterator just past the end of the container.">end()</a></code>. The iterator resulting from this function ultimately works by calling the derived class's <code>at_(size_type)const</code> member function.</p>
<dl class="section return"><dt>Returns</dt><dd>An iterator pointing at the first element in the container. The resulting iterator can not be used to modify the aliased elements.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">none</td><td>No throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a42154c41ac8331aaaef69b616e093ee5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42154c41ac8331aaaef69b616e093ee5">&#9670;&nbsp;</a></span>begin() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classutilities_1_1IndexableContainerBase.html#ab0e9d4191449adbdf96fa8da58675e4e">iterator</a> <a class="el" href="classutilities_1_1IndexableContainerBase.html">utilities::IndexableContainerBase</a>&lt; DerivedType &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator pointing at the first element in the container. </p>
<p>This member function is used to create an iterator that points to the first element in the container. If the container is empty the resulting iterator will be identical to the iterator returned by <code><a class="el" href="classutilities_1_1IndexableContainerBase.html#acca04d9cf31e393f9f08f06442056e63" title="Returns an iterator just past the end of the container.">end()</a></code>. The iterator resulting from this function ultimately works by calling the derived class's <code>at_(size_type)</code> member function.</p>
<dl class="section return"><dt>Returns</dt><dd>An iterator pointing at the first element in the container. The resulting iterator may be used to modify the container if the derived class's <code>at_(size_type)</code> member function returns read-/write- references.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">none</td><td>No throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9197cb8551971223b58afc8a99bd45b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9197cb8551971223b58afc8a99bd45b1">&#9670;&nbsp;</a></span>cbegin()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classutilities_1_1IndexableContainerBase.html#a4a63123c05b94040e275b4487cb9fa28">const_iterator</a> <a class="el" href="classutilities_1_1IndexableContainerBase.html">utilities::IndexableContainerBase</a>&lt; DerivedType &gt;::cbegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator pointing at the first element in the container. </p>
<p>This member function is used to create an iterator that points to the first element in the container. If the container is empty the resulting iterator will be identical to the iterator returned by <code><a class="el" href="classutilities_1_1IndexableContainerBase.html#acca04d9cf31e393f9f08f06442056e63" title="Returns an iterator just past the end of the container.">end()</a></code>. The iterator resulting from this function ultimately works by calling the derived class's <code>at_(size_type)const</code> member function.</p>
<dl class="section return"><dt>Returns</dt><dd>An iterator pointing at the first element in the container. The resulting iterator can not be used to modify the aliased elements.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">none</td><td>No throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa1ed119bdd7cc678c5e164fb0e792bad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1ed119bdd7cc678c5e164fb0e792bad">&#9670;&nbsp;</a></span>cend()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classutilities_1_1IndexableContainerBase.html#a4a63123c05b94040e275b4487cb9fa28">const_iterator</a> <a class="el" href="classutilities_1_1IndexableContainerBase.html">utilities::IndexableContainerBase</a>&lt; DerivedType &gt;::cend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator just past the end of the container. </p>
<p>This function is used to return an iterator that points to just past the end of the container. The resulting iterator is meant to serve as a semaphore for when iteration should stop; it should not be dereferenced and doing so is undefined behavior. This function ultimately works by calling the derived class's <code>size_()</code> member.</p>
<dl class="section return"><dt>Returns</dt><dd>An iterator pointing to just past the end of the container.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">None</td><td>No throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acb0a8881ca1bd39fb410847cad9ffcf3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb0a8881ca1bd39fb410847cad9ffcf3">&#9670;&nbsp;</a></span>empty()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classutilities_1_1IndexableContainerBase.html">utilities::IndexableContainerBase</a>&lt; DerivedType &gt;::empty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if the container has any elements in it or not. </p>
<p>This function can be used to determine if a container has any elements in it. This function ultimately works by calling the derived class's <code>size_()</code> member.</p>
<dl class="section return"><dt>Returns</dt><dd>True if this container has no elements and false otherwise.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">None.</td><td>No throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1b0f654673ca8e974ff6f923d5e54b05"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b0f654673ca8e974ff6f923d5e54b05">&#9670;&nbsp;</a></span>end() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classutilities_1_1IndexableContainerBase.html#a4a63123c05b94040e275b4487cb9fa28">const_iterator</a> <a class="el" href="classutilities_1_1IndexableContainerBase.html">utilities::IndexableContainerBase</a>&lt; DerivedType &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator just past the end of the container. </p>
<p>This function is used to return an iterator that points to just past the end of the container. The resulting iterator is meant to serve as a semaphore for when iteration should stop; it should not be dereferenced and doing so is undefined behavior. This function ultimately works by calling the derived class's <code>size_()</code> member.</p>
<dl class="section return"><dt>Returns</dt><dd>An iterator pointing to just past the end of the container.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">None</td><td>No throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acca04d9cf31e393f9f08f06442056e63"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acca04d9cf31e393f9f08f06442056e63">&#9670;&nbsp;</a></span>end() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classutilities_1_1IndexableContainerBase.html#ab0e9d4191449adbdf96fa8da58675e4e">iterator</a> <a class="el" href="classutilities_1_1IndexableContainerBase.html">utilities::IndexableContainerBase</a>&lt; DerivedType &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator just past the end of the container. </p>
<p>This function is used to return an iterator that points to just past the end of the container. The resulting iterator is meant to serve as a semaphore for when iteration should stop; it should not be dereferenced and doing so is undefined behavior. This function ultimately works by calling the derived class's <code>size_()</code> member.</p>
<dl class="section return"><dt>Returns</dt><dd>An iterator pointing to just past the end of the container.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">None</td><td>No throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af1d63487f1dcdb974df4ea778f80e0c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1d63487f1dcdb974df4ea778f80e0c5">&#9670;&nbsp;</a></span>operator[]() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) <a class="el" href="classutilities_1_1IndexableContainerBase.html">utilities::IndexableContainerBase</a>&lt; DerivedType &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classutilities_1_1IndexableContainerBase.html#abffb9e1bccc5e96f6a255e3879cf5cbd">size_type</a>&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieves an element from the container by index. </p>
<p>This function is used to retrieve an element given its index in the container. This function ultimately works by calling the derived class's <code>size_()</code> (for the bounds check) and <code>at_(size_type)</code> (for the retrieval) members.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>The index of the element to return. Must be in the range [0, <a class="el" href="classutilities_1_1IndexableContainerBase.html#a44d61c5622fad0691278da6aed0ffad4" title="Determines the number of elements in the container.">size()</a>).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The requested element as a (possibly) read/write reference.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::out_of_range</td><td>if <code>index</code> is not in the range [0, <a class="el" href="classutilities_1_1IndexableContainerBase.html#a44d61c5622fad0691278da6aed0ffad4" title="Determines the number of elements in the container.">size()</a>). Strong throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a03cb6845ef691898e764821d631dc941"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03cb6845ef691898e764821d631dc941">&#9670;&nbsp;</a></span>operator[]() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) <a class="el" href="classutilities_1_1IndexableContainerBase.html">utilities::IndexableContainerBase</a>&lt; DerivedType &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classutilities_1_1IndexableContainerBase.html#abffb9e1bccc5e96f6a255e3879cf5cbd">size_type</a>&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieves an element from the container by index. </p>
<p>This function is used to retrieve an element given its index in the container. This function ultimately works by calling the derived class's <code>size_()</code> (for the bounds check) and <code>at_(size_type)const</code> (for the retrieval) members.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>The index of the element to return. Must be in the range [0, <a class="el" href="classutilities_1_1IndexableContainerBase.html#a44d61c5622fad0691278da6aed0ffad4" title="Determines the number of elements in the container.">size()</a>).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The requested element as a read-only reference.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::out_of_range</td><td>if <code>index</code> is not in the range [0, <a class="el" href="classutilities_1_1IndexableContainerBase.html#a44d61c5622fad0691278da6aed0ffad4" title="Determines the number of elements in the container.">size()</a>). Strong throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a44d61c5622fad0691278da6aed0ffad4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44d61c5622fad0691278da6aed0ffad4">&#9670;&nbsp;</a></span>size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classutilities_1_1IndexableContainerBase.html#abffb9e1bccc5e96f6a255e3879cf5cbd">size_type</a> <a class="el" href="classutilities_1_1IndexableContainerBase.html">utilities::IndexableContainerBase</a>&lt; DerivedType &gt;::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines the number of elements in the container. </p>
<p>This function is used to get the number of elements in the container. It ultimately works by calling the derived class's <code>size_()</code> member.</p>
<dl class="section return"><dt>Returns</dt><dd>The number of elements in the container.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">None</td><td>No throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a id="a71944cf326d967694d7394081e67c166"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71944cf326d967694d7394081e67c166">&#9670;&nbsp;</a></span>operator!=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classutilities_1_1IndexableContainerBase.html">IndexableContainerBase</a>&lt; DerivedType &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classutilities_1_1IndexableContainerBase.html">IndexableContainerBase</a>&lt; DerivedType &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if two <a class="el" href="classutilities_1_1IndexableContainerBase.html" title="Code factorization for a container that supports indexing.">IndexableContainerBase</a> instances are different. </p>
<p>This operator ultimately works by calling the DerivedType's <code>size_()</code> and <code>const_reference at_(size_type)const</code> member functions. The containers are defined as equal if they are the same size and <code>lhs[i] == rhs[i]</code> holds for all <code>i</code> in the range [0, lhs.size()). "Different" is defined as "not equal".</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">DerivedType</td><td>The type of the container being implemented by the <a class="el" href="classutilities_1_1IndexableContainerBase.html" title="Code factorization for a container that supports indexing.">IndexableContainerBase</a> class.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">lhs</td><td>The instance on the left-side of the operator. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>The instance on the right-side of the operator.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>False if the containers contain the same number of elements and the same elements in the same order; true otherwise.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">None</td><td>No throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a36214ed92d82cef2963cbba092bbbefd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36214ed92d82cef2963cbba092bbbefd">&#9670;&nbsp;</a></span>operator==()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classutilities_1_1IndexableContainerBase.html">IndexableContainerBase</a>&lt; DerivedType &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classutilities_1_1IndexableContainerBase.html">IndexableContainerBase</a>&lt; DerivedType &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares two <a class="el" href="classutilities_1_1IndexableContainerBase.html" title="Code factorization for a container that supports indexing.">IndexableContainerBase</a> instances for equality. </p>
<p>This operator ultimately works by calling the DerivedType's <code>size_()</code> and <code>const_reference at_(size_type)const</code> member functions. The containers are defined as equal if they are the same size and <code>lhs[i] == rhs[i]</code> holds for all <code>i</code> in the range [0, lhs.size()).</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">DerivedType</td><td>The type of the container being implemented by the <a class="el" href="classutilities_1_1IndexableContainerBase.html" title="Code factorization for a container that supports indexing.">IndexableContainerBase</a> class.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">lhs</td><td>The instance on the left-side of the operator. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>The instance on the right-side of the operator.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the containers contain the same number of elements and the same elements in the same order; false otherwise.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">None</td><td>No throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>utilities/containers/<a class="el" href="indexable__container__base_8hpp_source.html">indexable_container_base.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
