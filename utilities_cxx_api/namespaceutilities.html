<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>utilities: utilities Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">utilities
   &#160;<span id="projectnumber">1.0.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">utilities Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Main namespace for the Utilities library.  
<a href="namespaceutilities.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespaceutilities_1_1detail__"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceutilities_1_1detail__.html">detail_</a></td></tr>
<tr class="memdesc:namespaceutilities_1_1detail__"><td class="mdescLeft">&#160;</td><td class="mdescRight">Name space for things not mean to see the light of day. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classutilities_1_1Combinations.html">Combinations</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A container that holds all combinations of a sequence.  <a href="classutilities_1_1Combinations.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structutilities_1_1Conjunction.html">Conjunction</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if all the types are true too.  <a href="structutilities_1_1Conjunction.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structutilities_1_1Conjunction_3_01B1_01_4.html">Conjunction&lt; B1 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structutilities_1_1Conjunction_3_01B1_00_01Bn_8_8_8_01_4.html">Conjunction&lt; B1, Bn... &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classutilities_1_1Enumerate.html">Enumerate</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enumerates the elements in a container.  <a href="classutilities_1_1Enumerate.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structutilities_1_1has__arrow.html">has_arrow</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if a type has the arrow operator.  <a href="structutilities_1_1has__arrow.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structutilities_1_1has__dereference.html">has_dereference</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if a type is dereference-able via the star operator.  <a href="structutilities_1_1has__dereference.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structutilities_1_1has__dereference_3_01T_00_01typename_01VoidType_3_01decltype_07_5std_1_1declvf530c08b2e833f04bbccaec8d005ee1a.html">has_dereference&lt; T, typename VoidType&lt; decltype(*std::declval&lt; T &gt;())&gt;::type &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structutilities_1_1has__postfix__decrement.html">has_postfix_decrement</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if a type implements the postfix decrement operator.  <a href="structutilities_1_1has__postfix__decrement.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structutilities_1_1has__postfix__decrement_3_01T_00_01typename_01VoidType_3_01decltype_07std_1_189de70649f76f38765574e30217d956d.html">has_postfix_decrement&lt; T, typename VoidType&lt; decltype(std::declval&lt; T &gt;() --)&gt;::type &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structutilities_1_1has__postfix__increment.html">has_postfix_increment</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if a type implements the postfix increment operator.  <a href="structutilities_1_1has__postfix__increment.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structutilities_1_1has__postfix__increment_3_01T_00_01typename_01VoidType_3_01decltype_07std_1_10d94e0a57d4a324f9146bbcb393f1467.html">has_postfix_increment&lt; T, typename VoidType&lt; decltype(std::declval&lt; T &gt;()++)&gt;::type &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structutilities_1_1has__prefix__decrement.html">has_prefix_decrement</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if a type implements the prefix decrement operator.  <a href="structutilities_1_1has__prefix__decrement.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structutilities_1_1has__prefix__decrement_3_01T_00_01typename_01VoidType_3_01decltype_07--std_1_6eca0d7d721834388c670a1a20244a9f.html">has_prefix_decrement&lt; T, typename VoidType&lt; decltype(--std::declval&lt; T &gt;())&gt;::type &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structutilities_1_1has__prefix__increment.html">has_prefix_increment</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if a type implements the prefix increment operator.  <a href="structutilities_1_1has__prefix__increment.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structutilities_1_1has__prefix__increment_3_01T_00_01typename_01VoidType_3_01decltype_07_09_09stf2cc41068d5dfe0687b63a3abe932aa2.html">has_prefix_increment&lt; T, typename VoidType&lt; decltype(++std::declval&lt; T &gt;())&gt;::type &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classutilities_1_1IndexableContainerBase.html">IndexableContainerBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Code factorization for a container that supports indexing.  <a href="classutilities_1_1IndexableContainerBase.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structutilities_1_1is__bidirectional__iterator.html">is_bidirectional_iterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This struct will contain a value true if the type satisfies the C++ concept of "BidirectionalIterator".  <a href="structutilities_1_1is__bidirectional__iterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structutilities_1_1is__container.html">is_container</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This struct will contain a value true if the type satisfies the C++ concept of "Container".  <a href="structutilities_1_1is__container.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structutilities_1_1is__indexable.html">is_indexable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if a type implements the index operator.  <a href="structutilities_1_1is__indexable.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structutilities_1_1is__indexable_3_01T_00_01typename_01VoidType_3_01decltype_07std_1_1declval_3_e36cb9467602774b885ccc2b25a87a84.html">is_indexable&lt; T, typename VoidType&lt; decltype(std::declval&lt; T &gt;()[0])&gt;::type &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structutilities_1_1is__input__iterator.html">is_input_iterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This struct will contain a value true if the type satisfies the C++ concept of "InputIterator".  <a href="structutilities_1_1is__input__iterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structutilities_1_1is__iterator.html">is_iterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This struct will contain a value true if the type satisfies the C++ concept of "Iterator".  <a href="structutilities_1_1is__iterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structutilities_1_1is__random__access__iterator.html">is_random_access_iterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This struct will contain a value true if the type satisfies the C++ concept of "RandomAccessIterator".  <a href="structutilities_1_1is__random__access__iterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classutilities_1_1MathSet.html">MathSet</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements an std::unordered_set-like object except that it knows about union, etc.  <a href="classutilities_1_1MathSet.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structutilities_1_1Negation.html">Negation</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the member value to the opposite of the input value.  <a href="structutilities_1_1Negation.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classutilities_1_1OwnOrBorrow.html">OwnOrBorrow</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class that provides a uniform API for accessing data regardless of whether it owns the data in it or aliases it.  <a href="classutilities_1_1OwnOrBorrow.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classutilities_1_1Permutations.html">Permutations</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Facilitates looping over all unique permutations of a set.  <a href="classutilities_1_1Permutations.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classutilities_1_1Range.html">Range</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Container that holds a range of integers.  <a href="classutilities_1_1Range.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classutilities_1_1SmartEnum.html">SmartEnum</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class to implement smart enumerations, based on strings.  <a href="classutilities_1_1SmartEnum.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classutilities_1_1StaticString.html">StaticString</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class capable of holding a compile-time manipulatable string.  <a href="classutilities_1_1StaticString.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classutilities_1_1Timer.html">Timer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Facilitates timing one or more functions.  <a href="classutilities_1_1Timer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structutilities_1_1VoidType.html">VoidType</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A type that is always void.  <a href="structutilities_1_1VoidType.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classutilities_1_1Zip.html">Zip</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A container filled with elements resulting from zipping containers together.  <a href="classutilities_1_1Zip.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a46b8e7ca5123e28b92af40ff0e5bf2b8"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a46b8e7ca5123e28b92af40ff0e5bf2b8"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceutilities.html#a46b8e7ca5123e28b92af40ff0e5bf2b8">CaseInsensitiveMap</a> = std::map&lt; std::string, T, <a class="el" href="structutilities_1_1detail___1_1CaseInsensitiveLess__.html">detail_::CaseInsensitiveLess_</a> &gt;</td></tr>
<tr class="memdesc:a46b8e7ca5123e28b92af40ff0e5bf2b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">A case-insensitive std::map (the keys are assumed to be std::string otherwise it doesn't make a whole lot of sense to do a case-insensitive compare...)  <a href="namespaceutilities.html#a46b8e7ca5123e28b92af40ff0e5bf2b8">More...</a><br /></td></tr>
<tr class="separator:a46b8e7ca5123e28b92af40ff0e5bf2b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a476bf7a49a7f2af8f20b3ba5631e7379"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a476bf7a49a7f2af8f20b3ba5631e7379"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceutilities.html#a476bf7a49a7f2af8f20b3ba5631e7379">is_forward_iterator</a> = <a class="el" href="structutilities_1_1is__input__iterator.html">is_input_iterator</a>&lt; T &gt;</td></tr>
<tr class="memdesc:a476bf7a49a7f2af8f20b3ba5631e7379"><td class="mdescLeft">&#160;</td><td class="mdescRight">This struct will contain a value true if the type satisfies the C++ concept of "ForwardIterator".  <a href="namespaceutilities.html#a476bf7a49a7f2af8f20b3ba5631e7379">More...</a><br /></td></tr>
<tr class="separator:a476bf7a49a7f2af8f20b3ba5631e7379"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab28d787819ccbe93afc46dfbe6f7f48e"><td class="memTemplParams" colspan="2"><a id="ab28d787819ccbe93afc46dfbe6f7f48e"></a>
template&lt;typename Base , typename Derived , typename U  = void&gt; </td></tr>
<tr class="memitem:ab28d787819ccbe93afc46dfbe6f7f48e"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceutilities.html#ab28d787819ccbe93afc46dfbe6f7f48e">enable_if_base_of_t</a> = std::enable_if_t&lt; std::is_base_of_v&lt; Base, Derived &gt;, U &gt;</td></tr>
<tr class="memdesc:ab28d787819ccbe93afc46dfbe6f7f48e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type alias for SFINAE enable-if checks on polymorphic types. <br /></td></tr>
<tr class="separator:ab28d787819ccbe93afc46dfbe6f7f48e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1886623539f2370f2775e1768913d0a4"><td class="memTemplParams" colspan="2"><a id="a1886623539f2370f2775e1768913d0a4"></a>
template&lt;typename Base , typename Derived , typename U  = void&gt; </td></tr>
<tr class="memitem:a1886623539f2370f2775e1768913d0a4"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>enable_if_not_base_of_t</b> = std::enable_if_t&lt;!std::is_base_of_v&lt; Base, Derived &gt;, U &gt;</td></tr>
<tr class="separator:a1886623539f2370f2775e1768913d0a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a286981143c3710fa4b2625eaf09c93d7"><td class="memTemplParams" colspan="2"><a id="a286981143c3710fa4b2625eaf09c93d7"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a286981143c3710fa4b2625eaf09c93d7"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceutilities.html#a286981143c3710fa4b2625eaf09c93d7">variant_to_tuple_t</a> = typename <a class="el" href="structutilities_1_1detail___1_1variant__to__tuple.html">detail_::variant_to_tuple</a>&lt; T &gt;::type</td></tr>
<tr class="memdesc:a286981143c3710fa4b2625eaf09c93d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Public API for getting the type of a tuple with the same types as a variant. <br /></td></tr>
<tr class="separator:a286981143c3710fa4b2625eaf09c93d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a6d951289c4ed72cc21f51b6e155b3ada"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a6d951289c4ed72cc21f51b6e155b3ada"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceutilities.html#a6d951289c4ed72cc21f51b6e155b3ada">operator==</a> (const <a class="el" href="classutilities_1_1OwnOrBorrow.html">OwnOrBorrow</a>&lt; T &gt; &amp;lhs, const <a class="el" href="classutilities_1_1OwnOrBorrow.html">OwnOrBorrow</a>&lt; T &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a6d951289c4ed72cc21f51b6e155b3ada"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if two <a class="el" href="classutilities_1_1OwnOrBorrow.html" title="Class that provides a uniform API for accessing data regardless of whether it owns the data in it or ...">OwnOrBorrow</a> instances are managing the same value.  <a href="namespaceutilities.html#a6d951289c4ed72cc21f51b6e155b3ada">More...</a><br /></td></tr>
<tr class="separator:a6d951289c4ed72cc21f51b6e155b3ada"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdc6f7209b2dea2952d12fb74afbb951"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:afdc6f7209b2dea2952d12fb74afbb951"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceutilities.html#afdc6f7209b2dea2952d12fb74afbb951">operator!=</a> (const <a class="el" href="classutilities_1_1OwnOrBorrow.html">OwnOrBorrow</a>&lt; T &gt; &amp;lhs, const <a class="el" href="classutilities_1_1OwnOrBorrow.html">OwnOrBorrow</a>&lt; T &gt; &amp;rhs) noexcept</td></tr>
<tr class="memdesc:afdc6f7209b2dea2952d12fb74afbb951"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if two <a class="el" href="classutilities_1_1OwnOrBorrow.html" title="Class that provides a uniform API for accessing data regardless of whether it owns the data in it or ...">OwnOrBorrow</a> instances are managing different values.  <a href="namespaceutilities.html#afdc6f7209b2dea2952d12fb74afbb951">More...</a><br /></td></tr>
<tr class="separator:afdc6f7209b2dea2952d12fb74afbb951"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5101d967151df2f88f518a0ee6bed4c6"><td class="memTemplParams" colspan="2">template&lt;typename... ContainerTypes&gt; </td></tr>
<tr class="memitem:a5101d967151df2f88f518a0ee6bed4c6"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceutilities.html#a5101d967151df2f88f518a0ee6bed4c6">CartesianProduct</a> (ContainerTypes &amp;&amp;... containers)</td></tr>
<tr class="memdesc:a5101d967151df2f88f518a0ee6bed4c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper function that makes a CartesianProduct container.  <a href="namespaceutilities.html#a5101d967151df2f88f518a0ee6bed4c6">More...</a><br /></td></tr>
<tr class="separator:a5101d967151df2f88f518a0ee6bed4c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0ac2baf94042546477c66897958c543"><td class="memTemplParams" colspan="2"><a id="aa0ac2baf94042546477c66897958c543"></a>
template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:aa0ac2baf94042546477c66897958c543"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><b>Enumerate</b> (Args &amp;&amp;...) -&gt; <a class="el" href="classutilities_1_1Enumerate.html">Enumerate</a>&lt; Args... &gt;</td></tr>
<tr class="separator:aa0ac2baf94042546477c66897958c543"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac693feb6291b7e307d51dba6332796fc"><td class="memTemplParams" colspan="2"><a id="ac693feb6291b7e307d51dba6332796fc"></a>
template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:ac693feb6291b7e307d51dba6332796fc"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><b>Zip</b> (Args &amp;&amp;...) -&gt; <a class="el" href="classutilities_1_1Zip.html">Zip</a>&lt; Args... &gt;</td></tr>
<tr class="separator:ac693feb6291b7e307d51dba6332796fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3774d0c9bd752e6758872cbaac51bfb3"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a3774d0c9bd752e6758872cbaac51bfb3"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceutilities.html#a3774d0c9bd752e6758872cbaac51bfb3">binomial_coefficient</a> (std::size_t n, std::size_t k)</td></tr>
<tr class="memdesc:a3774d0c9bd752e6758872cbaac51bfb3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the binomial coefficient <img class="formulaInl" alt="${n\choose k}$" src="form_4.png"/>.  <a href="namespaceutilities.html#a3774d0c9bd752e6758872cbaac51bfb3">More...</a><br /></td></tr>
<tr class="separator:a3774d0c9bd752e6758872cbaac51bfb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7270410a4ec9e203b145008c9bfbd008"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a7270410a4ec9e203b145008c9bfbd008"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceutilities.html#a7270410a4ec9e203b145008c9bfbd008">multinomial_coefficient</a> (const std::vector&lt; std::size_t &gt; &amp;ks) noexcept</td></tr>
<tr class="memdesc:a7270410a4ec9e203b145008c9bfbd008"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the multinomial coefficient <img class="formulaInl" alt="${{\sum k_i} \choose {\prod k_i!}}$" src="form_5.png"/>.  <a href="namespaceutilities.html#a7270410a4ec9e203b145008c9bfbd008">More...</a><br /></td></tr>
<tr class="separator:a7270410a4ec9e203b145008c9bfbd008"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d3453550bf873451bae967de3981847"><td class="memTemplParams" colspan="2">template&lt;typename container_type &gt; </td></tr>
<tr class="memitem:a7d3453550bf873451bae967de3981847"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceutilities.html#a7d3453550bf873451bae967de3981847">n_permutations</a> (const container_type &amp;seq)</td></tr>
<tr class="memdesc:a7d3453550bf873451bae967de3981847"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a sequence returns the number of unique permutations.  <a href="namespaceutilities.html#a7d3453550bf873451bae967de3981847">More...</a><br /></td></tr>
<tr class="separator:a7d3453550bf873451bae967de3981847"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f29c2bc554ff7096738f42b5ddc9ecb"><td class="memTemplParams" colspan="2">template&lt;typename container_type &gt; </td></tr>
<tr class="memitem:a1f29c2bc554ff7096738f42b5ddc9ecb"><td class="memTemplItemLeft" align="right" valign="top">std::deque&lt; std::size_t &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceutilities.html#a1f29c2bc554ff7096738f42b5ddc9ecb">permutation_to_fns</a> (const container_type &amp;perm, const container_type &amp;original)</td></tr>
<tr class="memdesc:a1f29c2bc554ff7096738f42b5ddc9ecb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a permutation this function maps that permutation to its value in the factorial number system.  <a href="namespaceutilities.html#a1f29c2bc554ff7096738f42b5ddc9ecb">More...</a><br /></td></tr>
<tr class="separator:a1f29c2bc554ff7096738f42b5ddc9ecb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a232c039921a794a3300c01af47887676"><td class="memTemplParams" colspan="2">template&lt;typename container_type &gt; </td></tr>
<tr class="memitem:a232c039921a794a3300c01af47887676"><td class="memTemplItemLeft" align="right" valign="top">container_type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceutilities.html#a232c039921a794a3300c01af47887676">fns_to_permutation</a> (const std::deque&lt; std::size_t &gt; &amp;fns, const container_type &amp;original)</td></tr>
<tr class="memdesc:a232c039921a794a3300c01af47887676"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a value in the factorial number system to the equivalent permutation.  <a href="namespaceutilities.html#a232c039921a794a3300c01af47887676">More...</a><br /></td></tr>
<tr class="separator:a232c039921a794a3300c01af47887676"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c5d4ec8453e99ed2f2ad10f7393f364"><td class="memTemplParams" colspan="2">template&lt;typename container_type &gt; </td></tr>
<tr class="memitem:a5c5d4ec8453e99ed2f2ad10f7393f364"><td class="memTemplItemLeft" align="right" valign="top">std::deque&lt; std::size_t &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceutilities.html#a5c5d4ec8453e99ed2f2ad10f7393f364">fns_place_values</a> (const container_type &amp;perm)</td></tr>
<tr class="memdesc:a5c5d4ec8453e99ed2f2ad10f7393f364"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a permutation of a sequence computes the values of the places in the number.  <a href="namespaceutilities.html#a5c5d4ec8453e99ed2f2ad10f7393f364">More...</a><br /></td></tr>
<tr class="separator:a5c5d4ec8453e99ed2f2ad10f7393f364"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19871243b308008cd80fa136caf5b689"><td class="memTemplParams" colspan="2">template&lt;typename container_type &gt; </td></tr>
<tr class="memitem:a19871243b308008cd80fa136caf5b689"><td class="memTemplItemLeft" align="right" valign="top">std::deque&lt; std::size_t &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceutilities.html#a19871243b308008cd80fa136caf5b689">decimal_to_fns</a> (std::size_t D, const container_type &amp;perm)</td></tr>
<tr class="memdesc:a19871243b308008cd80fa136caf5b689"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a decimal value and the original sequence, computes the corresponding value in the factorial number system.  <a href="namespaceutilities.html#a19871243b308008cd80fa136caf5b689">More...</a><br /></td></tr>
<tr class="separator:a19871243b308008cd80fa136caf5b689"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc4b558d16d5f471785edf8f10b51e12"><td class="memTemplParams" colspan="2">template&lt;typename container_type &gt; </td></tr>
<tr class="memitem:acc4b558d16d5f471785edf8f10b51e12"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceutilities.html#acc4b558d16d5f471785edf8f10b51e12">permutation_to_decimal</a> (const container_type &amp;perm, const container_type &amp;original)</td></tr>
<tr class="memdesc:acc4b558d16d5f471785edf8f10b51e12"><td class="mdescLeft">&#160;</td><td class="mdescRight">A convenience function for bypassing the FNS intermediate.  <a href="namespaceutilities.html#acc4b558d16d5f471785edf8f10b51e12">More...</a><br /></td></tr>
<tr class="separator:acc4b558d16d5f471785edf8f10b51e12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3d6fbe6bd2e1101525db9fa2f9dc7cc"><td class="memTemplParams" colspan="2">template&lt;typename container_type &gt; </td></tr>
<tr class="memitem:ac3d6fbe6bd2e1101525db9fa2f9dc7cc"><td class="memTemplItemLeft" align="right" valign="top">container_type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceutilities.html#ac3d6fbe6bd2e1101525db9fa2f9dc7cc">decimal_to_permutation</a> (std::size_t n, const container_type &amp;original)</td></tr>
<tr class="memdesc:ac3d6fbe6bd2e1101525db9fa2f9dc7cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">A convenience function for going from decimal to the corresponding permutation.  <a href="namespaceutilities.html#ac3d6fbe6bd2e1101525db9fa2f9dc7cc">More...</a><br /></td></tr>
<tr class="separator:ac3d6fbe6bd2e1101525db9fa2f9dc7cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b618bb285899fe732d71484c6698b62"><td class="memTemplParams" colspan="2">template&lt;typename SignedType  = long, typename UnsignedType  = std::size_t&gt; </td></tr>
<tr class="memitem:a3b618bb285899fe732d71484c6698b62"><td class="memTemplItemLeft" align="right" valign="top">SignedType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceutilities.html#a3b618bb285899fe732d71484c6698b62">UnsignedSubtract</a> (const UnsignedType &amp;lhs, const UnsignedType &amp;rhs) noexcept</td></tr>
<tr class="memdesc:a3b618bb285899fe732d71484c6698b62"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given two integer type instances this function will take their difference in a manner that will not lead to an overflow and will generate the correct sign on the result.  <a href="namespaceutilities.html#a3b618bb285899fe732d71484c6698b62">More...</a><br /></td></tr>
<tr class="separator:a3b618bb285899fe732d71484c6698b62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a418dd9ed736791a1e84c6b7801bd28b0"><td class="memItemLeft" align="right" valign="top"><a id="a418dd9ed736791a1e84c6b7801bd28b0"></a>
std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator&lt;&lt;</b> (std::ostream &amp;os, const <a class="el" href="classutilities_1_1Timer.html">Timer</a> &amp;t)</td></tr>
<tr class="separator:a418dd9ed736791a1e84c6b7801bd28b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad027649c245bd7e411e2155305cef0b2"><td class="memTemplParams" colspan="2">template&lt;typename tuple_type , typename functor_type &gt; </td></tr>
<tr class="memitem:ad027649c245bd7e411e2155305cef0b2"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceutilities.html#ad027649c245bd7e411e2155305cef0b2">tuple_transform</a> (tuple_type &amp;&amp;tuple, functor_type &amp;&amp;functor)</td></tr>
<tr class="memdesc:ad027649c245bd7e411e2155305cef0b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a tuple of objects this function will apply a functor to each of them and return the results as a tuple.  <a href="namespaceutilities.html#ad027649c245bd7e411e2155305cef0b2">More...</a><br /></td></tr>
<tr class="separator:ad027649c245bd7e411e2155305cef0b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace8cac62cfa90cdf3463f1112b5b6bcc"><td class="memTemplParams" colspan="2">template&lt;typename lhs_type , typename rhs_type , typename functor_type &gt; </td></tr>
<tr class="memitem:ace8cac62cfa90cdf3463f1112b5b6bcc"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceutilities.html#ace8cac62cfa90cdf3463f1112b5b6bcc">tuple_transform</a> (lhs_type &amp;&amp;lhs, rhs_type &amp;&amp;rhs, functor_type &amp;&amp;functor)</td></tr>
<tr class="memdesc:ace8cac62cfa90cdf3463f1112b5b6bcc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies a binary operation two tuples returning the result.  <a href="namespaceutilities.html#ace8cac62cfa90cdf3463f1112b5b6bcc">More...</a><br /></td></tr>
<tr class="separator:ace8cac62cfa90cdf3463f1112b5b6bcc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae651021596ff36720a7654eb78fce2b5"><td class="memTemplParams" colspan="2">template&lt;typename tuple_type , typename functor_type , typename return_type &gt; </td></tr>
<tr class="memitem:ae651021596ff36720a7654eb78fce2b5"><td class="memTemplItemLeft" align="right" valign="top">return_type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceutilities.html#ae651021596ff36720a7654eb78fce2b5">tuple_accumulate</a> (tuple_type &amp;&amp;tuple, functor_type &amp;&amp;functor, return_type val)</td></tr>
<tr class="memdesc:ae651021596ff36720a7654eb78fce2b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies a reduction to a tuple.  <a href="namespaceutilities.html#ae651021596ff36720a7654eb78fce2b5">More...</a><br /></td></tr>
<tr class="separator:ae651021596ff36720a7654eb78fce2b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2be3eccba3a5a2e170aec27390a6d1d5"><td class="memTemplParams" colspan="2">template&lt;typename tuple_type , typename functor_type &gt; </td></tr>
<tr class="memitem:a2be3eccba3a5a2e170aec27390a6d1d5"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceutilities.html#a2be3eccba3a5a2e170aec27390a6d1d5">tuple_find_if</a> (tuple_type &amp;&amp;t, functor_type &amp;&amp;functor)</td></tr>
<tr class="memdesc:a2be3eccba3a5a2e170aec27390a6d1d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies a functor to each element of a tuple and returns the index of the tuple element for which the functor first evaluates to true.  <a href="namespaceutilities.html#a2be3eccba3a5a2e170aec27390a6d1d5">More...</a><br /></td></tr>
<tr class="separator:a2be3eccba3a5a2e170aec27390a6d1d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1de73b0e095732a1f51cf33e9029bcbc"><td class="memItemLeft" align="right" valign="top"><a id="a1de73b0e095732a1f51cf33e9029bcbc"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>HAS_TYPE</b> (value_type)</td></tr>
<tr class="separator:a1de73b0e095732a1f51cf33e9029bcbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0959be3c1675d30232c9c97c3d659ce9"><td class="memItemLeft" align="right" valign="top"><a id="a0959be3c1675d30232c9c97c3d659ce9"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>HAS_TYPE</b> (reference)</td></tr>
<tr class="separator:a0959be3c1675d30232c9c97c3d659ce9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a41b63afd2cbe0f931a8049c8b78213"><td class="memItemLeft" align="right" valign="top"><a id="a9a41b63afd2cbe0f931a8049c8b78213"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>HAS_TYPE</b> (const_reference)</td></tr>
<tr class="separator:a9a41b63afd2cbe0f931a8049c8b78213"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e9781d3420bf558939c3dc3d55597e0"><td class="memItemLeft" align="right" valign="top"><a id="a2e9781d3420bf558939c3dc3d55597e0"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>HAS_TYPE</b> (pointer)</td></tr>
<tr class="separator:a2e9781d3420bf558939c3dc3d55597e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abedc2b2657b719924ce7417bf5a00e84"><td class="memItemLeft" align="right" valign="top"><a id="abedc2b2657b719924ce7417bf5a00e84"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>HAS_TYPE</b> (const_pointer)</td></tr>
<tr class="separator:abedc2b2657b719924ce7417bf5a00e84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28e33945884b43b6494a3771aa38e048"><td class="memItemLeft" align="right" valign="top"><a id="a28e33945884b43b6494a3771aa38e048"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>HAS_TYPE</b> (iterator)</td></tr>
<tr class="separator:a28e33945884b43b6494a3771aa38e048"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c8aa146d8f94edbc2b7719c34c8a757"><td class="memItemLeft" align="right" valign="top"><a id="a4c8aa146d8f94edbc2b7719c34c8a757"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>HAS_TYPE</b> (const_iterator)</td></tr>
<tr class="separator:a4c8aa146d8f94edbc2b7719c34c8a757"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0d0e66972a381fffe2edd6df540819b"><td class="memItemLeft" align="right" valign="top"><a id="ac0d0e66972a381fffe2edd6df540819b"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>HAS_TYPE</b> (difference_type)</td></tr>
<tr class="separator:ac0d0e66972a381fffe2edd6df540819b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16a0ccffa75ca8b36537df615680e23d"><td class="memItemLeft" align="right" valign="top"><a id="a16a0ccffa75ca8b36537df615680e23d"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>HAS_TYPE</b> (size_type)</td></tr>
<tr class="separator:a16a0ccffa75ca8b36537df615680e23d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04d28ce9a8922970bd1ad0e26c406579"><td class="memItemLeft" align="right" valign="top"><a id="a04d28ce9a8922970bd1ad0e26c406579"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>HAS_TYPE</b> (iterator_category)</td></tr>
<tr class="separator:a04d28ce9a8922970bd1ad0e26c406579"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bd1bd377922c8368a161ebbe959afda"><td class="memItemLeft" align="right" valign="top"><a id="a1bd1bd377922c8368a161ebbe959afda"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>HAS_MEMBER</b> (begin)</td></tr>
<tr class="separator:a1bd1bd377922c8368a161ebbe959afda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b8ef354093c3c6cc373b820d54e1399"><td class="memItemLeft" align="right" valign="top"><a id="a5b8ef354093c3c6cc373b820d54e1399"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>HAS_MEMBER</b> (end)</td></tr>
<tr class="separator:a5b8ef354093c3c6cc373b820d54e1399"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ba3328ed7c67661c4b752e568a92273"><td class="memItemLeft" align="right" valign="top"><a id="a8ba3328ed7c67661c4b752e568a92273"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>HAS_MEMBER</b> (cbegin)</td></tr>
<tr class="separator:a8ba3328ed7c67661c4b752e568a92273"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1bce201beb02cf59a562411366a8abb"><td class="memItemLeft" align="right" valign="top"><a id="aa1bce201beb02cf59a562411366a8abb"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>HAS_MEMBER</b> (cend)</td></tr>
<tr class="separator:aa1bce201beb02cf59a562411366a8abb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4153948623b6b55dd5f3b4fe1ed315dc"><td class="memItemLeft" align="right" valign="top"><a id="a4153948623b6b55dd5f3b4fe1ed315dc"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>HAS_MEMBER</b> (size)</td></tr>
<tr class="separator:a4153948623b6b55dd5f3b4fe1ed315dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d068120b5f2e0c3afff366418f4fd92"><td class="memItemLeft" align="right" valign="top"><a id="a1d068120b5f2e0c3afff366418f4fd92"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>HAS_MEMBER</b> (max_size)</td></tr>
<tr class="separator:a1d068120b5f2e0c3afff366418f4fd92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7acb5f62a5fed8b0148b69c47ffc5b54"><td class="memItemLeft" align="right" valign="top"><a id="a7acb5f62a5fed8b0148b69c47ffc5b54"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>HAS_MEMBER</b> (empty)</td></tr>
<tr class="separator:a7acb5f62a5fed8b0148b69c47ffc5b54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8261f31c0640adbb4403bcb4725d7d85"><td class="memItemLeft" align="right" valign="top"><a id="a8261f31c0640adbb4403bcb4725d7d85"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>HAS_OPERATOR</b> (equal_to,==)</td></tr>
<tr class="separator:a8261f31c0640adbb4403bcb4725d7d85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3599a334237fc470a26d159d1f305462"><td class="memItemLeft" align="right" valign="top"><a id="a3599a334237fc470a26d159d1f305462"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>HAS_OPERATOR</b> (not_equal_to, !=)</td></tr>
<tr class="separator:a3599a334237fc470a26d159d1f305462"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeffd09e4777f575b181ee8859cde20af"><td class="memItemLeft" align="right" valign="top"><a id="aeffd09e4777f575b181ee8859cde20af"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>HAS_OPERATOR</b> (less_than,&lt;)</td></tr>
<tr class="separator:aeffd09e4777f575b181ee8859cde20af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5246334e6e9a4d266fe1e68082af2565"><td class="memItemLeft" align="right" valign="top"><a id="a5246334e6e9a4d266fe1e68082af2565"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>HAS_OPERATOR</b> (greater_than, &gt;)</td></tr>
<tr class="separator:a5246334e6e9a4d266fe1e68082af2565"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2320f5df7da61e824ea69d3e07ff19bb"><td class="memItemLeft" align="right" valign="top"><a id="a2320f5df7da61e824ea69d3e07ff19bb"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>HAS_OPERATOR</b> (less_than_equal,&lt;=)</td></tr>
<tr class="separator:a2320f5df7da61e824ea69d3e07ff19bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a664b42d8995d43b4cf1dee9f57ae1e20"><td class="memItemLeft" align="right" valign="top"><a id="a664b42d8995d43b4cf1dee9f57ae1e20"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>HAS_OPERATOR</b> (greater_than_equal, &gt;=)</td></tr>
<tr class="separator:a664b42d8995d43b4cf1dee9f57ae1e20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39196a1f8fb92e2fc7f5eb372fe1bec2"><td class="memItemLeft" align="right" valign="top"><a id="a39196a1f8fb92e2fc7f5eb372fe1bec2"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>HAS_OPERATOR</b> (increment_by,+=)</td></tr>
<tr class="separator:a39196a1f8fb92e2fc7f5eb372fe1bec2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c91685f9c5c8e5249376d4c285ed8fc"><td class="memItemLeft" align="right" valign="top"><a id="a8c91685f9c5c8e5249376d4c285ed8fc"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>HAS_OPERATOR</b> (decrement_by, -=)</td></tr>
<tr class="separator:a8c91685f9c5c8e5249376d4c285ed8fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf160be7609dae1dd302bb0a4800c6dc"><td class="memItemLeft" align="right" valign="top"><a id="aaf160be7609dae1dd302bb0a4800c6dc"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>HAS_OPERATOR</b> (plus,+)</td></tr>
<tr class="separator:aaf160be7609dae1dd302bb0a4800c6dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa422aac1f94e9c12228369fe5aa5c8ab"><td class="memItemLeft" align="right" valign="top"><a id="aa422aac1f94e9c12228369fe5aa5c8ab"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>HAS_OPERATOR</b> (minus, -)</td></tr>
<tr class="separator:aa422aac1f94e9c12228369fe5aa5c8ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Main namespace for the Utilities library. </p>
<p>Namespace for all functionality in the Utilities library. </p>
</div><h2 class="groupheader">Typedef Documentation</h2>
<a id="a46b8e7ca5123e28b92af40ff0e5bf2b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46b8e7ca5123e28b92af40ff0e5bf2b8">&#9670;&nbsp;</a></span>CaseInsensitiveMap</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceutilities.html#a46b8e7ca5123e28b92af40ff0e5bf2b8">utilities::CaseInsensitiveMap</a> = typedef std::map&lt;std::string, T, <a class="el" href="structutilities_1_1detail___1_1CaseInsensitiveLess__.html">detail_::CaseInsensitiveLess_</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A case-insensitive std::map (the keys are assumed to be std::string otherwise it doesn't make a whole lot of sense to do a case-insensitive compare...) </p>
<p>This class is really just a partial specialization of std::map so it's API is simply that of std::map.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>the type of values you are putting into the map </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a476bf7a49a7f2af8f20b3ba5631e7379"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a476bf7a49a7f2af8f20b3ba5631e7379">&#9670;&nbsp;</a></span>is_forward_iterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceutilities.html#a476bf7a49a7f2af8f20b3ba5631e7379">utilities::is_forward_iterator</a> = typedef <a class="el" href="structutilities_1_1is__input__iterator.html">is_input_iterator</a>&lt;T&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This struct will contain a value true if the type satisfies the C++ concept of "ForwardIterator". </p>
<dl class="section note"><dt>Note</dt><dd>A forward iterator is just an input iterator with a multipass guarantee. We currently are not checking for this hence this struct is only a typedef for clarity.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>This type will not check if the type is swappable. A type_trait, is_swappable exists in C++17 for this purpose. Implementing our own is a royal pain on account of how the STL actually does swapping...</dd></dl>
<p>The full specificiation of what an "forward iterator" must have is available &lt; a href="http://en.cppreference.com/w/cpp/concept/ForwardIterator"&gt;here. </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a3774d0c9bd752e6758872cbaac51bfb3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3774d0c9bd752e6758872cbaac51bfb3">&#9670;&nbsp;</a></span>binomial_coefficient()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T utilities::binomial_coefficient </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>k</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the binomial coefficient <img class="formulaInl" alt="${n\choose k}$" src="form_4.png"/>. </p>
<p>Depending on the requested return type a different algorithm is used. If the user requests an integral return type an algorithm based on Pascal's triangle will be used. If the user requests a floating point return type it will then be assumed that the user is fine with loosing precision <em>i.e.</em> the value will be returned in scientific notation with the significand truncated to the precision of the floating point value.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The desired return type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>top number of the bc <em>i.e.</em> number of objects to pick from </td></tr>
    <tr><td class="paramname">k</td><td>bottom number of the bc <em>i.e.</em> number of objects to pick at a time </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The requested value of the binomial coefficient </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::overflow_error</td><td>if the requested binomial coefficient can not be held in the requested return type. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5101d967151df2f88f518a0ee6bed4c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5101d967151df2f88f518a0ee6bed4c6">&#9670;&nbsp;</a></span>CartesianProduct()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... ContainerTypes&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto utilities::CartesianProduct </td>
          <td>(</td>
          <td class="paramtype">ContainerTypes &amp;&amp;...&#160;</td>
          <td class="paramname"><em>containers</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wrapper function that makes a CartesianProduct container. </p>
<p>The purpose/usage of the resulting object is perhaps best explained with an example. Consider the following snippet.</p>
<div class="fragment"><div class="line">std::vector&lt;int&gt; list1({1,2,3});</div>
<div class="line">std::vector&lt;int&gt; list2({2,3});</div>
<div class="line"><span class="keywordflow">for</span>(<span class="keyword">auto</span>&amp; x : <a class="code" href="namespaceutilities.html#a5101d967151df2f88f518a0ee6bed4c6">CartesianProduct</a>(list1.begin(),list2.begin())</div>
<div class="line">    std::cout&lt;&lt; std::get&lt;0&gt;(x) &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; std::get&lt;1&gt;(x) &lt;&lt;std::endl;</div>
</div><!-- fragment --><p>The result would be:</p>
<pre class="fragment">*  1 2
*  1 3
*  2 2
*  2 3
*  3 2
*  3 3
*  </pre><p>Thus the resulting class makes all possible tuples (in lexicographical order) that can be made from the elements in ean container.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ContainerTypes</td><td>The types of the containers to form the tuples from. Must minimally meet the concept of container. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">containers</td><td>The actual container instances to zip together. Containers will be captured by reference or constant reference as appropriate. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A TupleContainerImpl instance that is usable in a foreach loop </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">???</td><td>Throws if any of the size() members throw. Strong throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a19871243b308008cd80fa136caf5b689"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19871243b308008cd80fa136caf5b689">&#9670;&nbsp;</a></span>decimal_to_fns()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename container_type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::deque&lt; std::size_t &gt; utilities::decimal_to_fns </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>D</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const container_type &amp;&#160;</td>
          <td class="paramname"><em>perm</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given a decimal value and the original sequence, computes the corresponding value in the factorial number system. </p>
<p>Mapping a number in the factorial number system (FNS) to decimal is done by taking the inner product of the number's digits and the place values. This function is the inverse mapping, taking a value in decimal and returning the value in the FNS.</p>
<dl class="section user"><dt>Memory</dt><dd>The current algorithm requires two copies of <code>perm</code> and a call to n_permutations. Additionally memory for the return will be allocated.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">D</td><td>The requested permutation. <code>D</code> must be in the range [0, <img class="formulaInl" alt="$N$" src="form_6.png"/>) where <img class="formulaInl" alt="$N$" src="form_6.png"/> is the number of permutations of <code>perm</code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">perm</td><td>The original permutation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">container_type</td><td>The type of <code>perm</code>. Must satisfy the concept of a container. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The value of the <code>D</code> -th permutation in the factorial number system. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::bad_alloc</td><td>if memory allocation fails. Strong throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac3d6fbe6bd2e1101525db9fa2f9dc7cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3d6fbe6bd2e1101525db9fa2f9dc7cc">&#9670;&nbsp;</a></span>decimal_to_permutation()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename container_type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">container_type utilities::decimal_to_permutation </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const container_type &amp;&#160;</td>
          <td class="paramname"><em>original</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A convenience function for going from decimal to the corresponding permutation. </p>
<dl class="section user"><dt>Memory</dt><dd></dd></dl>
<p>Ultimately this calls fns_to_permutation and decimal_to_fns and thus has the same footprints.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">container_type</td><td>The type of the original sequence. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>The index of the requested permutation </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">original</td><td>The original sequence </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The requested permutation </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::bad_alloc</td><td>if either of the two subroutines run out of memory </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5c5d4ec8453e99ed2f2ad10f7393f364"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c5d4ec8453e99ed2f2ad10f7393f364">&#9670;&nbsp;</a></span>fns_place_values()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename container_type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::deque&lt; std::size_t &gt; utilities::fns_place_values </td>
          <td>(</td>
          <td class="paramtype">const container_type &amp;&#160;</td>
          <td class="paramname"><em>perm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given a permutation of a sequence computes the values of the places in the number. </p>
<p>For a description of the factorial number system see the Intro to Combinatorics section of the manual. Since for a general permutation the values of the places depends on the permutation this function will compute the place values.</p>
<dl class="section user"><dt>Memory</dt><dd>At the moment the internal algorithm is recursive requiring a copy of <code>perm</code> at each depth <img class="formulaInl" alt="$i$" src="form_11.png"/>; the copy will contain <img class="formulaInl" alt="$i$" src="form_11.png"/> less elements than <code>perm</code>. Additionally a call to n_permutations will be made at each depth. Finally, memory for the return type will be allocated.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">container_type</td><td>The type of the sequences </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">perm</td><td>The current permutation </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The value of the places in the factorial number system </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::bad_alloc</td><td>if any memory allocation fails. Strong throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a232c039921a794a3300c01af47887676"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a232c039921a794a3300c01af47887676">&#9670;&nbsp;</a></span>fns_to_permutation()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename container_type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">container_type utilities::fns_to_permutation </td>
          <td>(</td>
          <td class="paramtype">const std::deque&lt; std::size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>fns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const container_type &amp;&#160;</td>
          <td class="paramname"><em>original</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts a value in the factorial number system to the equivalent permutation. </p>
<dl class="section user"><dt>Memory</dt><dd></dd></dl>
<p>This call ultimately will call decimal_to_fns and therefore incurs its memory overhead as well as that of the return value.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">fns</td><td>The value in the factorial number system to convert to a permutation. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">original</td><td>The original permutation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The requested permutation. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::bad_alloc</td><td>if there is insufficient memory to complete the operation. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7270410a4ec9e203b145008c9bfbd008"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7270410a4ec9e203b145008c9bfbd008">&#9670;&nbsp;</a></span>multinomial_coefficient()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T utilities::multinomial_coefficient </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>ks</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the multinomial coefficient <img class="formulaInl" alt="${{\sum k_i} \choose {\prod k_i!}}$" src="form_5.png"/>. </p>
<p>Given <img class="formulaInl" alt="$N$" src="form_6.png"/> observations taken from <img class="formulaInl" alt="$M$" src="form_7.png"/> unique choices such that the <img class="formulaInl" alt="$i^\text{th}$" src="form_8.png"/> unique choice is observed <img class="formulaInl" alt="$m_i$" src="form_9.png"/> times, the multinomial coefficient <img class="formulaInl" alt="${ N \choose {\prod_{i=1}^M m_i!}}$" src="form_10.png"/>, is the number of possible orderings for those observations.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ks</td><td>The number of times each unique observation occurs. </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The desired return type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>sum of <code>ks</code> choose k0!,k1!,... </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">None.</td><td>No throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7d3453550bf873451bae967de3981847"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d3453550bf873451bae967de3981847">&#9670;&nbsp;</a></span>n_permutations()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename container_type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::size_t utilities::n_permutations </td>
          <td>(</td>
          <td class="paramtype">const container_type &amp;&#160;</td>
          <td class="paramname"><em>seq</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given a sequence returns the number of unique permutations. </p>
<p>This function is primarily code factorization. Basically, given a sequence we can't assume all elements are unique so we can't assume its just the length of the sequence factorial. Rather, we need to figure out the number of times each unique element appears in the sequence and then use that information to compute the appropriate multinomial coefficient.</p>
<dl class="section user"><dt>Memory</dt><dd>The present algorithm will make a copy of <code>seq</code> and an std::vector&lt;std::size_t&gt; of the length of <code>seq</code>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">seq</td><td>The sequence for which we wish to know the number of permutations. </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">container_type</td><td>The type of <code>seq</code>. Must satisfy the sequence concept. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of unique permutations of a sequence </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::bad_alloc</td><td>if there is not enough memory. Strong throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afdc6f7209b2dea2952d12fb74afbb951"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afdc6f7209b2dea2952d12fb74afbb951">&#9670;&nbsp;</a></span>operator!=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool utilities::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classutilities_1_1OwnOrBorrow.html">OwnOrBorrow</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classutilities_1_1OwnOrBorrow.html">OwnOrBorrow</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if two <a class="el" href="classutilities_1_1OwnOrBorrow.html" title="Class that provides a uniform API for accessing data regardless of whether it owns the data in it or ...">OwnOrBorrow</a> instances are managing different values. </p>
<p>This function compares the managed values using operator== and negates the result. In particular this means we are not determining if the two instances are aliasing different instances only that the values compare different.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of the managed value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">lhs</td><td>The instance on the left side of the comparison operator. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>The instance <code>lhs</code> is being compared to. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>False if T::operator== returns true and true if T::operator== returns false. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">???</td><td>if T::operator== throws. Same throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6d951289c4ed72cc21f51b6e155b3ada"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d951289c4ed72cc21f51b6e155b3ada">&#9670;&nbsp;</a></span>operator==()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool utilities::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classutilities_1_1OwnOrBorrow.html">OwnOrBorrow</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classutilities_1_1OwnOrBorrow.html">OwnOrBorrow</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines if two <a class="el" href="classutilities_1_1OwnOrBorrow.html" title="Class that provides a uniform API for accessing data regardless of whether it owns the data in it or ...">OwnOrBorrow</a> instances are managing the same value. </p>
<p>This function compares the managed values using operator== and returns the result. In particular this means we are not determining if the two instances are aliasing the same instance, only that the values compare equal.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of the managed value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">lhs</td><td>The instance on the left side of the comparison operator. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>The instance <code>lhs</code> is being compared to. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if T::operator== returns true and false if T::operator== returns false. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">???</td><td>if T::operator== throws. Same throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acc4b558d16d5f471785edf8f10b51e12"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc4b558d16d5f471785edf8f10b51e12">&#9670;&nbsp;</a></span>permutation_to_decimal()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename container_type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::size_t utilities::permutation_to_decimal </td>
          <td>(</td>
          <td class="paramtype">const container_type &amp;&#160;</td>
          <td class="paramname"><em>perm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const container_type &amp;&#160;</td>
          <td class="paramname"><em>original</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A convenience function for bypassing the FNS intermediate. </p>
<dl class="section user"><dt>Memory</dt><dd>This is ultimately a thin wrapper around permutation_to_fns and fns_place_values. It thus has their combined memory footprints.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">container_type</td><td>The type of the two sequences. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">perm</td><td>The permutation for which we want the decimal representation </td></tr>
    <tr><td class="paramname">original</td><td>The original sequence </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The decimal representation of the permutation. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::bad_alloc</td><td>if either of the two sub calls run out of memory. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1f29c2bc554ff7096738f42b5ddc9ecb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f29c2bc554ff7096738f42b5ddc9ecb">&#9670;&nbsp;</a></span>permutation_to_fns()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename container_type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::deque&lt; std::size_t &gt; utilities::permutation_to_fns </td>
          <td>(</td>
          <td class="paramtype">const container_type &amp;&#160;</td>
          <td class="paramname"><em>perm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const container_type &amp;&#160;</td>
          <td class="paramname"><em>original</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given a permutation this function maps that permutation to its value in the factorial number system. </p>
<p>For a description of the factorial number system see the Intro to Combinatorics section of the manual.</p>
<dl class="section user"><dt>Memory</dt><dd>The current algorithm is recursive and thus at a depth <img class="formulaInl" alt="$i$" src="form_11.png"/> will require two copies of <code>perm</code> (except they contain <img class="formulaInl" alt="$i-1$" src="form_12.png"/> less elements). Memory for the return type will also be allocated.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">container_type</td><td>The type of the sequences </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">perm</td><td>A permutation of <code>original</code> </td></tr>
    <tr><td class="paramname">original</td><td>The original sequence from which <code>perm</code> was generated </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The value of <code>perm</code> in the factorial number system. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::bad_alloc</td><td>if memory allocation fails. Strong throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae651021596ff36720a7654eb78fce2b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae651021596ff36720a7654eb78fce2b5">&#9670;&nbsp;</a></span>tuple_accumulate()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename tuple_type , typename functor_type , typename return_type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">return_type utilities::tuple_accumulate </td>
          <td>(</td>
          <td class="paramtype">tuple_type &amp;&amp;&#160;</td>
          <td class="paramname"><em>tuple</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">functor_type &amp;&amp;&#160;</td>
          <td class="paramname"><em>functor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">return_type&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Applies a reduction to a tuple. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tuple</td><td>The tuple to reduce </td></tr>
    <tr><td class="paramname">functor</td><td>The functor instance to use to do the reduction </td></tr>
    <tr><td class="paramname">val</td><td>The initial value for the reduction. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The value resulting from reducing all elements of the tuple</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">tuple_type</td><td>The type of the tuple we are reducing</td></tr>
    <tr><td class="paramname">functor_type</td><td>The type of the functor doing the reduction. Must define a member() with the signature: <div class="fragment"><div class="line"><span class="comment">//Applies the functor to a tuple element combining it</span></div>
<div class="line"><span class="comment">//param sum is the current reduction total</span></div>
<div class="line"><span class="comment">//param element is the element to reduce into sum</span></div>
<div class="line"><span class="comment">//return is the result of reducing sum and element</span></div>
<div class="line">return_type operator()(return_type sum, tuple_element element);</div>
</div><!-- fragment --></td></tr>
    <tr><td class="paramname">return_type</td><td>The type resulting from a reduction.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">???</td><td>Throws if any application of the functor to the tuple throws. Throw guarantee is same as that of functor. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2be3eccba3a5a2e170aec27390a6d1d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2be3eccba3a5a2e170aec27390a6d1d5">&#9670;&nbsp;</a></span>tuple_find_if()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename tuple_type , typename functor_type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::size_t utilities::tuple_find_if </td>
          <td>(</td>
          <td class="paramtype">tuple_type &amp;&amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">functor_type &amp;&amp;&#160;</td>
          <td class="paramname"><em>functor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Applies a functor to each element of a tuple and returns the index of the tuple element for which the functor first evaluates to true. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">tuple_type</td><td>The type of the tuple. </td></tr>
    <tr><td class="paramname">functor_type</td><td>The type of a unary functor used to "select" an element of the tuple. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>The tuple. </td></tr>
    <tr><td class="paramname">functor</td><td>The functor instance to apply to each element of the tuple. Should define a member function bool operator()(T&amp;&amp;) which will be called for the evaluation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The index for which the functor first evaluates to true or the size of the tuple if no entry evaluates to true. </dd></dl>

</div>
</div>
<a id="ace8cac62cfa90cdf3463f1112b5b6bcc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace8cac62cfa90cdf3463f1112b5b6bcc">&#9670;&nbsp;</a></span>tuple_transform() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename lhs_type , typename rhs_type , typename functor_type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto utilities::tuple_transform </td>
          <td>(</td>
          <td class="paramtype">lhs_type &amp;&amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">rhs_type &amp;&amp;&#160;</td>
          <td class="paramname"><em>rhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">functor_type &amp;&amp;&#160;</td>
          <td class="paramname"><em>functor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Applies a binary operation two tuples returning the result. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">lhs_type</td><td>The type of the tuple on the left of the operation. </td></tr>
    <tr><td class="paramname">rhs_type</td><td>The type of the tuple on the right of the operation. </td></tr>
    <tr><td class="paramname">functor_type</td><td>They type of the binary operation to apply </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The tuple on the left. </td></tr>
    <tr><td class="paramname">rhs</td><td>The tuple on the right. </td></tr>
    <tr><td class="paramname">functor</td><td>The actual functor instance to apply. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A tuple whose <img class="formulaInl" alt="$i$" src="form_11.png"/>-th element contains the result of applying <code>functor</code> to the <img class="formulaInl" alt="$i$" src="form_11.png"/>-th element of <code>lhs</code> and <code>rhs</code>. </dd></dl>

</div>
</div>
<a id="ad027649c245bd7e411e2155305cef0b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad027649c245bd7e411e2155305cef0b2">&#9670;&nbsp;</a></span>tuple_transform() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename tuple_type , typename functor_type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto utilities::tuple_transform </td>
          <td>(</td>
          <td class="paramtype">tuple_type &amp;&amp;&#160;</td>
          <td class="paramname"><em>tuple</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">functor_type &amp;&amp;&#160;</td>
          <td class="paramname"><em>functor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given a tuple of objects this function will apply a functor to each of them and return the results as a tuple. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">tuple</td><td>The tuple to apply the functor to. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">functor</td><td>An instance of the functor to use.</td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">tuple_type</td><td>The type of the std::tuple we are applying a functor to. </td></tr>
    <tr><td class="paramname">functor_type</td><td>The type of the functor we are applying to the tuple. The functor's operator() must be take a single argument, which will be one of the tuple's elements (hence for tuples with hetrogenous types, it must be templated on the input type). Hint: one can use auto as the return type to avoid having to do additional template meta-programming. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3b618bb285899fe732d71484c6698b62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b618bb285899fe732d71484c6698b62">&#9670;&nbsp;</a></span>UnsignedSubtract()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SignedType  = long, typename UnsignedType  = std::size_t&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">SignedType utilities::UnsignedSubtract </td>
          <td>(</td>
          <td class="paramtype">const UnsignedType &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const UnsignedType &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Given two integer type instances this function will take their difference in a manner that will not lead to an overflow and will generate the correct sign on the result. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">SignedType</td><td>The type of the result. Should be a signed integral POD type. </td></tr>
    <tr><td class="paramname">UnsignedType</td><td>The type of the input values. Should be an unsigned integral POD type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>The number of the left of the minus sign. </td></tr>
    <tr><td class="paramname">rhs</td><td>The number on the right of the minus sign. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The signed difference between <code>lhs</code> and <code>rhs</code>. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">None.</td><td>No throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
<div class="ttc" id="anamespaceutilities_html_a5101d967151df2f88f518a0ee6bed4c6"><div class="ttname"><a href="namespaceutilities.html#a5101d967151df2f88f518a0ee6bed4c6">utilities::CartesianProduct</a></div><div class="ttdeci">auto CartesianProduct(ContainerTypes &amp;&amp;... containers)</div><div class="ttdoc">Wrapper function that makes a CartesianProduct container.</div><div class="ttdef"><b>Definition:</b> cartesian_product.hpp:117</div></div>
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
